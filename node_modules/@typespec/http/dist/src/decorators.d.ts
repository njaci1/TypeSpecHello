import { DecoratorContext, Model, ModelProperty, Namespace, Operation, Program, Tuple, Type, Union } from "@typespec/compiler";
import { HeaderFieldOptions, HttpVerb, PathParameterOptions, QueryParameterOptions, ServiceAuthentication } from "./types.js";
export declare const namespace = "TypeSpec.Http";
export declare function $header(context: DecoratorContext, entity: ModelProperty, headerNameOrOptions?: string | Model): void;
export declare function getHeaderFieldOptions(program: Program, entity: Type): HeaderFieldOptions;
export declare function getHeaderFieldName(program: Program, entity: Type): string;
export declare function isHeader(program: Program, entity: Type): boolean;
export declare function $query(context: DecoratorContext, entity: ModelProperty, queryNameOrOptions?: string | Model): void;
export declare function getQueryParamOptions(program: Program, entity: Type): QueryParameterOptions;
export declare function getQueryParamName(program: Program, entity: Type): string;
export declare function isQueryParam(program: Program, entity: Type): boolean;
export declare function $path(context: DecoratorContext, entity: ModelProperty, paramName?: string): void;
export declare function getPathParamOptions(program: Program, entity: Type): PathParameterOptions;
export declare function getPathParamName(program: Program, entity: Type): string;
export declare function isPathParam(program: Program, entity: Type): boolean;
export declare function $body(context: DecoratorContext, entity: ModelProperty): void;
export declare function isBody(program: Program, entity: Type): boolean;
export declare function $statusCode(context: DecoratorContext, entity: ModelProperty): void;
export declare function setStatusCode(program: Program, entity: Model | ModelProperty, codes: string[]): void;
export declare function isStatusCode(program: Program, entity: Type): boolean;
export declare function getStatusCodes(program: Program, entity: Type): string[];
export declare function getStatusCodeDescription(statusCode: string): "The request has succeeded." | "The request has succeeded and a new resource has been created as a result." | "The request has been accepted for processing, but processing has not yet completed." | "There is no content to send for this request, but the headers may be useful. " | "The URL of the requested resource has been changed permanently. The new URL is given in the response." | "The client has made a conditional request and the resource has not been modified." | "The server could not understand the request due to invalid syntax." | "Access is unauthorized." | "Access is forbidden" | "The server cannot find the requested resource." | "The request conflicts with the current state of the server." | "Precondition failed." | "Service unavailable." | "Informational" | "Successful" | "Redirection" | "Client Error" | "Server Error" | undefined;
export declare function getOperationVerb(program: Program, entity: Type): HttpVerb | undefined;
export declare function $get(context: DecoratorContext, entity: Operation): void;
export declare function $put(context: DecoratorContext, entity: Operation): void;
export declare function $post(context: DecoratorContext, entity: Operation): void;
export declare function $patch(context: DecoratorContext, entity: Operation): void;
export declare function $delete(context: DecoratorContext, entity: Operation): void;
export declare function $head(context: DecoratorContext, entity: Operation): void;
export interface HttpServer {
    url: string;
    description: string;
    parameters: Map<string, ModelProperty>;
}
/**
 * Configure the server url for the service.
 * @param context Decorator context
 * @param target Decorator target(Must be a namespace)
 * @param description Description for this server.
 * @param parameters @optional Parameters to interpolate in the server url.
 */
export declare function $server(context: DecoratorContext, target: Namespace, url: string, description: string, parameters?: Model): void;
export declare function getServers(program: Program, type: Namespace): HttpServer[] | undefined;
export declare function $plainData(context: DecoratorContext, entity: Type): void;
export declare function $useAuth(context: DecoratorContext, serviceNamespace: Namespace, authConfig: Model | Union | Tuple): void;
export declare function setAuthentication(program: Program, serviceNamespace: Namespace, auth: ServiceAuthentication): void;
export declare function getAuthentication(program: Program, namespace: Namespace): ServiceAuthentication | undefined;
/**
 * `@route` defines the relative route URI for the target operation
 *
 * The first argument should be a URI fragment that may contain one or more path parameter fields.
 * If the namespace or interface that contains the operation is also marked with a `@route` decorator,
 * it will be used as a prefix to the route URI of the operation.
 *
 * `@route` can only be applied to operations, namespaces, and interfaces.
 */
export declare function $route(context: DecoratorContext, entity: Type, path: string, parameters?: Model): void;
/**
 * `@sharedRoute` marks the operation as sharing a route path with other operations.
 *
 * When an operation is marked with `@sharedRoute`, it enables other operations to share the same
 * route path as long as those operations are also marked with `@sharedRoute`.
 *
 * `@sharedRoute` can only be applied directly to operations.
 */
export declare function $sharedRoute(context: DecoratorContext, entity: Operation): void;
/**
 * Specifies if inapplicable metadata should be included in the payload for
 * the given entity. This is true by default unless changed by this
 * decorator.
 *
 * @param entity Target model, namespace, or model property. If applied to a
 *               model or namespace, applies recursively to child models,
 *               namespaces, and model properties unless overridden by
 *               applying this decorator to a child.
 *
 * @param value `true` to include inapplicable metadata in payload, false to
 *               exclude it.
 *
 * @see isApplicableMetadata
 */
export declare function $includeInapplicableMetadataInPayload(context: DecoratorContext, entity: Type, value: boolean): void;
/**
 * Determines if the given model property should be included in the payload if it is
 * inapplicable metadata.
 *
 * @see isApplicableMetadata
 * @see $includeInapplicableMetadataInPayload
 */
export declare function includeInapplicableMetadataInPayload(program: Program, property: ModelProperty): boolean;
//# sourceMappingURL=decorators.d.ts.map