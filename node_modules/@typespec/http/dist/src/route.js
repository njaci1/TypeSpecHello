import { createDiagnosticCollector, validateDecoratorTarget, } from "@typespec/compiler";
import { createDiagnostic, createStateSymbol, reportDiagnostic } from "./lib.js";
import { getOperationParameters } from "./parameters.js";
import { extractParamsFromPath } from "./utils.js";
// The set of allowed segment separator characters
const AllowedSegmentSeparators = ["/", ":"];
function normalizeFragment(fragment) {
    if (fragment.length > 0 && AllowedSegmentSeparators.indexOf(fragment[0]) < 0) {
        // Insert the default separator
        fragment = `/${fragment}`;
    }
    // Trim any trailing slash
    return fragment.replace(/\/$/g, "");
}
function buildPath(pathFragments) {
    // Join all fragments with leading and trailing slashes trimmed
    const path = pathFragments.length === 0
        ? "/"
        : pathFragments
            .map(normalizeFragment)
            .filter((x) => x !== "")
            .join("");
    // The final path must start with a '/'
    return path.length > 0 && path[0] === "/" ? path : `/${path}`;
}
export function resolvePathAndParameters(program, operation, overloadBase, options) {
    const diagnostics = createDiagnosticCollector();
    const { segments, parameters } = diagnostics.pipe(getRouteSegments(program, operation, overloadBase, options));
    // Pull out path parameters to verify what's in the path string
    const paramByName = new Set(parameters.parameters.filter(({ type }) => type === "path").map(({ param }) => param.name));
    // Ensure that all of the parameters defined in the route are accounted for in
    // the operation parameters
    const routeParams = segments.flatMap(extractParamsFromPath);
    for (const routeParam of routeParams) {
        if (!paramByName.has(routeParam)) {
            diagnostics.add(createDiagnostic({
                code: "missing-path-param",
                format: { param: routeParam },
                target: operation,
            }));
        }
    }
    return diagnostics.wrap({
        path: buildPath(segments),
        pathSegments: segments,
        parameters,
    });
}
function collectSegmentsAndOptions(program, source) {
    var _a, _b;
    if (source === undefined)
        return [[], {}];
    const [parentSegments, parentOptions] = collectSegmentsAndOptions(program, source.namespace);
    const route = (_a = getRoutePath(program, source)) === null || _a === void 0 ? void 0 : _a.path;
    const options = source.kind === "Namespace" ? (_b = getRouteOptionsForNamespace(program, source)) !== null && _b !== void 0 ? _b : {} : {};
    return [[...parentSegments, ...(route ? [route] : [])], { ...parentOptions, ...options }];
}
function getRouteSegments(program, operation, overloadBase, options) {
    var _a, _b;
    const diagnostics = createDiagnosticCollector();
    const [parentSegments, parentOptions] = collectSegmentsAndOptions(program, (_a = operation.interface) !== null && _a !== void 0 ? _a : operation.namespace);
    const routeProducer = (_b = getRouteProducer(program, operation)) !== null && _b !== void 0 ? _b : DefaultRouteProducer;
    const result = diagnostics.pipe(routeProducer(program, operation, parentSegments, overloadBase, {
        ...parentOptions,
        ...options,
    }));
    return diagnostics.wrap(result);
}
const externalInterfaces = createStateSymbol("externalInterfaces");
/**
 * @deprecated DO NOT USE. For internal use only as a workaround.
 * @param program Program
 * @param target Target namespace
 * @param sourceInterface Interface that should be included in namespace.
 */
export function includeInterfaceRoutesInNamespace(program, target, sourceInterface) {
    let array = program.stateMap(externalInterfaces).get(target);
    if (array === undefined) {
        array = [];
        program.stateMap(externalInterfaces).set(target, array);
    }
    array.push(sourceInterface);
}
const routeProducerKey = createStateSymbol("routeProducer");
export function DefaultRouteProducer(program, operation, parentSegments, overloadBase, options) {
    var _a;
    const diagnostics = createDiagnosticCollector();
    const routePath = (_a = getRoutePath(program, operation)) === null || _a === void 0 ? void 0 : _a.path;
    const segments = !routePath && overloadBase
        ? overloadBase.pathSegments
        : [...parentSegments, ...(routePath ? [routePath] : [])];
    const routeParams = segments.flatMap(extractParamsFromPath);
    const parameters = diagnostics.pipe(getOperationParameters(program, operation, overloadBase, routeParams, options.paramOptions));
    // Pull out path parameters to verify what's in the path string
    const unreferencedPathParamNames = new Set(parameters.parameters.filter(({ type }) => type === "path").map(({ param }) => param.name));
    // Compile the list of all route params that aren't represented in the route
    for (const routeParam of routeParams) {
        unreferencedPathParamNames.delete(routeParam);
    }
    // Add any remaining declared path params
    for (const paramName of unreferencedPathParamNames) {
        segments.push(`{${paramName}}`);
    }
    return diagnostics.wrap({
        segments,
        parameters,
    });
}
export function setRouteProducer(program, operation, routeProducer) {
    program.stateMap(routeProducerKey).set(operation, routeProducer);
}
export function getRouteProducer(program, operation) {
    return program.stateMap(routeProducerKey).get(operation);
}
const routesKey = createStateSymbol("routes");
export function setRoute(context, entity, details) {
    if (!validateDecoratorTarget(context, entity, "@route", ["Namespace", "Interface", "Operation"])) {
        return;
    }
    const state = context.program.stateMap(routesKey);
    if (state.has(entity) && entity.kind === "Namespace") {
        const existingPath = state.get(entity);
        if (existingPath !== details.path) {
            reportDiagnostic(context.program, {
                code: "duplicate-route-decorator",
                messageId: "namespace",
                target: entity,
            });
        }
    }
    else {
        state.set(entity, details.path);
        if (entity.kind === "Operation" && details.shared) {
            setSharedRoute(context.program, entity);
        }
    }
}
const sharedRoutesKey = createStateSymbol("sharedRoutes");
export function setSharedRoute(program, operation) {
    program.stateMap(sharedRoutesKey).set(operation, true);
}
export function isSharedRoute(program, operation) {
    return program.stateMap(sharedRoutesKey).get(operation) === true;
}
export function getRoutePath(program, entity) {
    const path = program.stateMap(routesKey).get(entity);
    return path
        ? {
            path,
            shared: entity.kind === "Operation" && isSharedRoute(program, entity),
        }
        : undefined;
}
const routeOptionsKey = createStateSymbol("routeOptions");
export function setRouteOptionsForNamespace(program, namespace, options) {
    program.stateMap(routeOptionsKey).set(namespace, options);
}
export function getRouteOptionsForNamespace(program, namespace) {
    return program.stateMap(routeOptionsKey).get(namespace);
}
//# sourceMappingURL=route.js.map