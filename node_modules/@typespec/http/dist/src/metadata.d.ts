import { DiagnosticCollector, ModelProperty, Program, Type } from "@typespec/compiler";
import { HttpVerb } from "./types.js";
/**
 * Flags enum representation of well-known visibilities that are used in
 * REST API.
 */
export declare enum Visibility {
    Read = 1,
    Create = 2,
    Update = 4,
    Delete = 8,
    Query = 16,
    None = 0,
    All = 31,
    /**
     * Additional flag to indicate when something is nested in a collection
     * and therefore no metadata is applicable.
     */
    Item = 1048576
}
/**
 * Provides a naming suffix to create a unique name for a type with this
 * visibility.
 *
 * The canonical visibility (default Visibility.Read) gets empty suffix,
 * otherwise visibilities are joined in pascal-case with `Or`. And `Item` is
 * if `Visibility.Item` is produced.
 *
 * Examples (with canonicalVisibility = Visibility.Read):
 *  - Visibility.Read => ""
 *  - Visibility.Update => "Update"
 *  - Visibility.Create | Visibility.Update => "CreateOrUpdate"
 *  - Visibility.Create | Visibility.Item => "CreateItem"
 *  - Visibility.Create | Visibility.Update | Visibility.Item => "CreateOrUpdateItem"
 *  */
export declare function getVisibilitySuffix(visibility: Visibility, canonicalVisibility?: Visibility | undefined): string;
/**
 * Determines the visibility to use for a request with the given verb.
 *
 * - GET | HEAD => Visibility.Query
 * - POST => Visibility.Update
 * - PUT => Visibility.Create | Update
 * - DELETE => Visibility.Delete
 */
export declare function getRequestVisibility(verb: HttpVerb): Visibility;
/**
 * Walks the given type and collects all applicable metadata and `@body`
 * properties recursively.
 */
export declare function gatherMetadata(program: Program, diagnostics: DiagnosticCollector, // currently unused, but reserved for future diagnostics
type: Type, visibility: Visibility, isMetadataCallback?: typeof isMetadata): Set<ModelProperty>;
/**
 * Determines if a property is metadata. A property is defined to be
 * metadata if it is marked `@header`, `@query`, `@path`, or `@statusCode`.
 */
export declare function isMetadata(program: Program, property: ModelProperty): boolean;
/**
 * Determines if the given property is visible with the given visibility.
 */
export declare function isVisible(program: Program, property: ModelProperty, visibility: Visibility): boolean;
/**
 * Determines if the given property is metadata that is applicable with the
 * given visibility.
 *
 * - No metadata is applicable with Visibility.Item present.
 * - If only Visibility.Read is present, then only `@header` and `@status`
 *   properties are applicable.
 * - If Visibility.Read is not present, all metadata properties other than
 *   `@statusCode` are applicable.
 */
export declare function isApplicableMetadata(program: Program, property: ModelProperty, visibility: Visibility, isMetadataCallback?: typeof isMetadata): boolean;
/**
 * Determines if the given property is metadata or marked `@body` and
 * applicable with the given visibility.
 */
export declare function isApplicableMetadataOrBody(program: Program, property: ModelProperty, visibility: Visibility, isMetadataCallback?: typeof isMetadata): boolean;
/**
 * Provides information about changes that happen to a data type's payload
 * when inapplicable metadata is added or invisible properties are removed.
 *
 * Results are computed on demand and expensive computations are memoized.
 */
export interface MetadataInfo {
    /**
     * Determines if the given type is a model that becomes empty once
     * applicable metadata is removed and visibility is applied.
     *
     * Note that a model is not considered emptied if it was already empty in
     * the first place, or has a base model or indexer.
     *
     * When the type of a property is emptied by visibility, the property
     * itself is also removed.
     */
    isEmptied(type: Type | undefined, visibility: Visibility): boolean;
    /**
     * Determines if the given type is transformed by applying the given
     * visibility and removing invisible properties or adding inapplicable
     * metadata properties.
     */
    isTransformed(type: Type | undefined, visibility: Visibility): boolean;
    /**
     * Determines if the given property is part of the request or response
     * payload and not applicable metadata {@link isApplicableMetadata} or
     * filtered out by the given visibility.
     */
    isPayloadProperty(property: ModelProperty, visibility: Visibility): boolean;
    /**
     * Determines if the given property is optional in the request or
     * response payload for the given visibility.
     */
    isOptional(property: ModelProperty, visibility: Visibility): boolean;
    /**
     * If type is an anonymous model, tries to find a named model that has the
     * same set of properties when non-payload properties are excluded.
     */
    getEffectivePayloadType(type: Type, visibility: Visibility): Type;
}
export interface MetadataInfoOptions {
    /**
     * The visibility to be used as the baseline against which
     * {@link MetadataInfo.isEmptied} and {@link MetadataInfo.isTransformed}
     * are computed. If not specified, {@link Visibility.None} is used, which
     * will consider that any model that has fields that are only visible to
     * some visibilities as transformed.
     */
    canonicalVisibility?: Visibility;
    /**
     * Optional callback to indicate that a property can be shared with the
     * canonical representation even for visibilities where it is not visible.
     *
     * This is used, for example, in OpenAPI emit where a property can be
     * marked `readOnly: true` to represent @visibility("read") without
     * creating a separate schema schema for {@link Visibility.Read}.
     */
    canShareProperty?(property: ModelProperty): boolean;
}
export declare function createMetadataInfo(program: Program, options?: MetadataInfoOptions): MetadataInfo;
//# sourceMappingURL=metadata.d.ts.map