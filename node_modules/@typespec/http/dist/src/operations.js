import { $visibility, createDiagnosticCollector, getOverloadedOperation, getOverloads, getVisibility, listOperationsIn, listServices, navigateProgram, SyntaxKind, } from "@typespec/compiler";
import { createDiagnostic, reportDiagnostic } from "./lib.js";
import { getResponsesForOperation } from "./responses.js";
import { isSharedRoute, resolvePathAndParameters } from "./route.js";
/**
 * Return the Http Operation details for a given TypeSpec operation.
 * @param operation Operation
 * @param options Optional option on how to resolve the http details.
 */
export function getHttpOperation(program, operation, options) {
    return getHttpOperationInternal(program, operation, options, new Map());
}
/**
 * Get all the Http Operation in the given container.
 * @param program Program
 * @param container Namespace or interface containing operations
 * @param options Resolution options
 * @returns
 */
export function listHttpOperationsIn(program, container, options) {
    const diagnostics = createDiagnosticCollector();
    const operations = listOperationsIn(container, options === null || options === void 0 ? void 0 : options.listOptions);
    const cache = new Map();
    const httpOperations = operations.map((x) => diagnostics.pipe(getHttpOperationInternal(program, x, options, cache)));
    return diagnostics.wrap(httpOperations);
}
/**
 * Returns all the services defined.
 */
export function getAllHttpServices(program, options) {
    const diagnostics = createDiagnosticCollector();
    const serviceNamespaces = listServices(program);
    const services = serviceNamespaces.map((x) => diagnostics.pipe(getHttpService(program, x.type, options)));
    if (serviceNamespaces.length === 0) {
        services.push(diagnostics.pipe(getHttpService(program, program.getGlobalNamespaceType(), options)));
    }
    return diagnostics.wrap(services);
}
export function getHttpService(program, serviceNamespace, options) {
    const diagnostics = createDiagnosticCollector();
    const httpOperations = diagnostics.pipe(listHttpOperationsIn(program, serviceNamespace, {
        ...options,
        listOptions: {
            recursive: serviceNamespace !== program.getGlobalNamespaceType(),
        },
    }));
    validateProgram(program, diagnostics);
    validateRouteUnique(program, diagnostics, httpOperations);
    const service = {
        namespace: serviceNamespace,
        operations: httpOperations,
    };
    return diagnostics.wrap(service);
}
/**
 * @deprecated use `getAllHttpServices` or `resolveHttpOperations` manually
 */
export function getAllRoutes(program, options) {
    const [services, diagnostics] = getAllHttpServices(program, options);
    return [services[0].operations, diagnostics];
}
export function reportIfNoRoutes(program, routes) {
    if (routes.length === 0) {
        reportDiagnostic(program, {
            code: "no-routes",
            target: program.getGlobalNamespaceType(),
        });
    }
}
export function validateRouteUnique(program, diagnostics, operations) {
    const grouped = new Map();
    for (const operation of operations) {
        const { verb, path } = operation;
        if (operation.overloading !== undefined && isOverloadSameEndpoint(operation)) {
            continue;
        }
        if (isSharedRoute(program, operation.operation)) {
            continue;
        }
        let map = grouped.get(path);
        if (map === undefined) {
            map = new Map();
            grouped.set(path, map);
        }
        let list = map.get(verb);
        if (list === undefined) {
            list = [];
            map.set(verb, list);
        }
        list.push(operation);
    }
    for (const [path, map] of grouped) {
        for (const [verb, routes] of map) {
            if (routes.length >= 2) {
                for (const route of routes) {
                    diagnostics.add(createDiagnostic({
                        code: "duplicate-operation",
                        format: { path, verb, operationName: route.operation.name },
                        target: route.operation,
                    }));
                }
            }
        }
    }
}
export function isOverloadSameEndpoint(overload) {
    return overload.path === overload.overloading.path && overload.verb === overload.overloading.verb;
}
function getHttpOperationInternal(program, operation, options, cache) {
    var _a, _b;
    const existing = cache.get(operation);
    if (existing) {
        return [existing, []];
    }
    const diagnostics = createDiagnosticCollector();
    const httpOperationRef = { operation };
    cache.set(operation, httpOperationRef);
    const overloadBase = getOverloadedOperation(program, operation);
    let overloading;
    if (overloadBase) {
        overloading = httpOperationRef.overloading = diagnostics.pipe(getHttpOperationInternal(program, overloadBase, options, cache));
    }
    const route = diagnostics.pipe(resolvePathAndParameters(program, operation, overloading, options !== null && options !== void 0 ? options : {}));
    const responses = diagnostics.pipe(getResponsesForOperation(program, operation));
    const httpOperation = {
        path: route.path,
        pathSegments: route.pathSegments,
        verb: route.parameters.verb,
        container: (_b = (_a = operation.interface) !== null && _a !== void 0 ? _a : operation.namespace) !== null && _b !== void 0 ? _b : program.getGlobalNamespaceType(),
        parameters: route.parameters,
        operation,
        responses,
    };
    Object.assign(httpOperationRef, httpOperation);
    const overloads = getOverloads(program, operation);
    if (overloads) {
        httpOperationRef.overloads = overloads.map((x) => diagnostics.pipe(getHttpOperationInternal(program, x, options, cache)));
    }
    return diagnostics.wrap(httpOperationRef);
}
function validateProgram(program, diagnostics) {
    navigateProgram(program, {
        modelProperty(property) {
            checkForUnsupportedVisibility(property);
        },
    });
    // NOTE: This is intentionally not checked in the visibility decorator
    // itself as that would be a layering violation, putting a REST
    // interpretation of visibility into the core.
    function checkForUnsupportedVisibility(property) {
        var _a, _b;
        if ((_a = getVisibility(program, property)) === null || _a === void 0 ? void 0 : _a.includes("write")) {
            // NOTE: Check for name equality instead of function equality
            // to deal with multiple copies of core being used.
            const decorator = property.decorators.find((d) => d.decorator.name === $visibility.name);
            const arg = decorator === null || decorator === void 0 ? void 0 : decorator.args.find((a) => { var _a; return ((_a = a.node) === null || _a === void 0 ? void 0 : _a.kind) === SyntaxKind.StringLiteral && a.node.value === "write"; });
            const target = (_b = arg === null || arg === void 0 ? void 0 : arg.node) !== null && _b !== void 0 ? _b : property;
            diagnostics.add(createDiagnostic({ code: "write-visibility-not-supported", target }));
        }
    }
}
//# sourceMappingURL=operations.js.map