var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _VersioningTimeline_namespaces, _VersioningTimeline_timeline, _VersioningTimeline_momentIndex, _VersioningTimeline_versionIndex, _TimelineMoment_versionMap;
import { compilerAssert, getTypeName } from "@typespec/compiler";
import { getVersions } from "./versioning.js";
/**
 * Represent a timeline of all the version involved in the versioning of a namespace
 *
 * @example
 * Given the following namespaces with their versions
 * ```
 * Library:
 *  l1
 *  l2
 *  l3
 *  l4
 *
 * Service:
 *  v1  -> (using) l1
 *  v2  -> (using) l3
 *  v3  -> (using) l3
 * ```
 *
 * This would be the data passed to the constructor
 * ```ts
 * new VersioningTimeline(program, [
 *   new Map([[serviceNs, v1], [libraryNs, l1]]),
 *   new Map([[serviceNs, v2], [libraryNs, l3]]),
 *   new Map([[serviceNs, v3], [libraryNs, l3]]),
 * ])
 * ```
 *
 * The following timeline is going to be represented
 *
 * | Service | Library |
 * |---------|---------|
 * |   v1    |   l1    |
 * |         |   l2    |
 * |   v2    |   l3    |
 * |   v3    |   l3    |
 * |         |   l4    |
 */
export class VersioningTimeline {
    constructor(program, resolutions) {
        _VersioningTimeline_namespaces.set(this, void 0);
        _VersioningTimeline_timeline.set(this, void 0);
        _VersioningTimeline_momentIndex.set(this, void 0);
        _VersioningTimeline_versionIndex.set(this, void 0);
        const indexedVersions = new Set();
        const namespaces = new Set();
        const timeline = (__classPrivateFieldSet(this, _VersioningTimeline_timeline, resolutions.map((x) => new TimelineMoment(x)), "f"));
        for (const resolution of resolutions) {
            for (const [namespace, version] of resolution.entries()) {
                indexedVersions.add(version);
                namespaces.add(namespace);
            }
        }
        __classPrivateFieldSet(this, _VersioningTimeline_namespaces, [...namespaces], "f");
        function findIndexToInsert(version) {
            for (const [index, moment] of timeline.entries()) {
                const versionAtMoment = moment.getVersion(version.namespace);
                if (versionAtMoment && version.index < versionAtMoment.index) {
                    return index;
                }
            }
            return -1;
        }
        for (const namespace of namespaces) {
            const [, versions] = getVersions(program, namespace);
            if (versions === undefined) {
                continue;
            }
            for (const version of versions.getVersions()) {
                if (!indexedVersions.has(version)) {
                    indexedVersions.add(version);
                    const index = findIndexToInsert(version);
                    const newMoment = new TimelineMoment(new Map([[version.namespace, version]]));
                    if (index === -1) {
                        timeline.push(newMoment);
                    }
                    else {
                        timeline.splice(index, 0, newMoment);
                    }
                }
            }
        }
        __classPrivateFieldSet(this, _VersioningTimeline_versionIndex, new Map(), "f");
        __classPrivateFieldSet(this, _VersioningTimeline_momentIndex, new Map(), "f");
        for (const [index, moment] of timeline.entries()) {
            __classPrivateFieldGet(this, _VersioningTimeline_momentIndex, "f").set(moment, index);
            for (const version of moment.versions()) {
                if (!__classPrivateFieldGet(this, _VersioningTimeline_versionIndex, "f").has(version)) {
                    __classPrivateFieldGet(this, _VersioningTimeline_versionIndex, "f").set(version, index);
                }
            }
        }
    }
    prettySerialize() {
        const hSep = "-".repeat(__classPrivateFieldGet(this, _VersioningTimeline_namespaces, "f").length * 13 + 1);
        const content = __classPrivateFieldGet(this, _VersioningTimeline_timeline, "f")
            .map((moment) => {
            return ("| " +
                __classPrivateFieldGet(this, _VersioningTimeline_namespaces, "f")
                    .map((x) => { var _a, _b; return ((_b = (_a = moment.getVersion(x)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "").padEnd(10, " "); })
                    .join(" | ") +
                " |");
        })
            .join(`\n${hSep}\n`);
        return ["", hSep, content, hSep].join("\n");
    }
    get(version) {
        const index = this.getIndex(version);
        if (index === -1) {
            if (version instanceof TimelineMoment) {
                compilerAssert(false, `Timeline moment "${version === null || version === void 0 ? void 0 : version.name}" should have been resolved`);
            }
            else {
                compilerAssert(false, `Version "${version === null || version === void 0 ? void 0 : version.name}" from ${getTypeName(version.namespace)} should have been resolved. ${this.prettySerialize()}`);
            }
        }
        return __classPrivateFieldGet(this, _VersioningTimeline_timeline, "f")[index];
    }
    /**
     * Return index in the timeline that this version points to
     * Returns -1 if version is not found.
     */
    getIndex(version) {
        const index = version instanceof TimelineMoment
            ? __classPrivateFieldGet(this, _VersioningTimeline_momentIndex, "f").get(version)
            : __classPrivateFieldGet(this, _VersioningTimeline_versionIndex, "f").get(version);
        if (index === undefined) {
            return -1;
        }
        return index;
    }
    /**
     * Return true if {@link isBefore} is before {@link base}
     * @param isBefore
     * @param base
     */
    isBefore(isBefore, base) {
        const isBeforeIndex = this.getIndex(isBefore);
        const baseIndex = this.getIndex(base);
        return isBeforeIndex < baseIndex;
    }
    first() {
        return __classPrivateFieldGet(this, _VersioningTimeline_timeline, "f")[0];
    }
    [(_VersioningTimeline_namespaces = new WeakMap(), _VersioningTimeline_timeline = new WeakMap(), _VersioningTimeline_momentIndex = new WeakMap(), _VersioningTimeline_versionIndex = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _VersioningTimeline_timeline, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _VersioningTimeline_timeline, "f").entries();
    }
}
export class TimelineMoment {
    constructor(versionMap) {
        var _a;
        _TimelineMoment_versionMap.set(this, void 0);
        __classPrivateFieldSet(this, _TimelineMoment_versionMap, versionMap, "f");
        this.name = (_a = versionMap.values().next().value) !== null && _a !== void 0 ? _a : "";
    }
    getVersion(namespace) {
        return __classPrivateFieldGet(this, _TimelineMoment_versionMap, "f").get(namespace);
    }
    versions() {
        return __classPrivateFieldGet(this, _TimelineMoment_versionMap, "f").values();
    }
}
_TimelineMoment_versionMap = new WeakMap();
//# sourceMappingURL=versioning-timeline.js.map