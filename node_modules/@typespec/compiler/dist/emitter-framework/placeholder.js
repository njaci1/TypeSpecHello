var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Placeholder_listeners;
/**
 * Keeps track of a value we don't know yet because of a circular reference. Use
 * the `onValue` method to provide a callback with how to handle the
 * placeholder's value becoming available. Generally the callback will replace
 * this placeholder with the value in whatever references the placeholder.
 */
export class Placeholder {
    constructor() {
        _Placeholder_listeners.set(this, []);
    }
    setValue(value) {
        for (const listener of __classPrivateFieldGet(this, _Placeholder_listeners, "f")) {
            listener(value);
        }
    }
    onValue(cb) {
        __classPrivateFieldGet(this, _Placeholder_listeners, "f").push(cb);
    }
}
_Placeholder_listeners = new WeakMap();
//# sourceMappingURL=placeholder.js.map