import { ok } from "assert";
import { pathToFileURL } from "url";
import { TextDocument } from "vscode-languageserver-textdocument";
import { parse, visitChildren } from "../core/parser.js";
import { SyntaxKind } from "../core/types.js";
import { createStringMap } from "../core/util.js";
import { createServer } from "../server/index.js";
import { StandardTestLibrary, createTestFileSystem, resolveVirtualPath, } from "./test-host.js";
export async function createTestServerHost(options) {
    var _a;
    const logMessages = [];
    const documents = createStringMap(!!(options === null || options === void 0 ? void 0 : options.caseInsensitiveFileSystem));
    const diagnostics = createStringMap(!!(options === null || options === void 0 ? void 0 : options.caseInsensitiveFileSystem));
    const fileSystem = await createTestFileSystem({ ...options, excludeTestLib: true });
    await fileSystem.addTypeSpecLibrary(StandardTestLibrary);
    const serverHost = {
        ...fileSystem,
        throwInternalErrors: true,
        server: undefined,
        logMessages,
        getOpenDocumentByURL(url) {
            return documents.get(url);
        },
        getOpenDocument(path) {
            return this.getOpenDocumentByURL(this.getURL(path));
        },
        addOrUpdateDocument(path, content) {
            const url = this.getURL(path);
            let version = 1;
            const oldDocument = documents.get(url);
            if (oldDocument) {
                version = oldDocument.version;
                if (oldDocument.getText() !== content) {
                    version++;
                }
            }
            const document = TextDocument.create(url, "typespec", version, content);
            documents.set(url, document);
            fileSystem.addTypeSpecFile(path, ""); // force virtual file system to create directory where document lives.
            return document;
        },
        getDiagnostics(path) {
            var _a;
            return (_a = diagnostics.get(this.getURL(path))) !== null && _a !== void 0 ? _a : [];
        },
        sendDiagnostics(params) {
            var _a;
            if (params.version && ((_a = documents.get(params.uri)) === null || _a === void 0 ? void 0 : _a.version) !== params.version) {
                return;
            }
            diagnostics.set(params.uri, params.diagnostics);
        },
        log(message) {
            logMessages.push(message);
        },
        getURL(path) {
            if (path.startsWith("untitled:")) {
                return path;
            }
            return pathToFileURL(resolveVirtualPath(path)).href;
        },
    };
    const workspaceDir = (_a = options === null || options === void 0 ? void 0 : options.workspaceDir) !== null && _a !== void 0 ? _a : "./";
    const rootUri = serverHost.getURL(workspaceDir);
    const server = createServer(serverHost);
    await server.initialize({
        rootUri: (options === null || options === void 0 ? void 0 : options.caseInsensitiveFileSystem) ? rootUri.toUpperCase() : rootUri,
        capabilities: {},
        processId: null,
        workspaceFolders: null,
    });
    server.initialized({});
    serverHost.server = server;
    return serverHost;
}
/**
 * Takes source code with a cursor position indicated by the given marker
 * ("┆" by default), and returns the source without the marker along with
 * the cursor position.
 */
export function extractCursor(sourceWithCursor, marker = "┆") {
    const pos = sourceWithCursor.indexOf(marker);
    ok(pos >= 0, "marker not found");
    const source = sourceWithCursor.replace(marker, "");
    return { source, pos };
}
/**
 * Takes source code with start and end positions indicated by given marker
 * ("~~~" by default) and returns the source without the markers along with
 * the start and end positions.
 */
export function extractSquiggles(sourceWithSquiggles, marker = "~~~") {
    const { source: sourceWithoutFistSquiggle, pos } = extractCursor(sourceWithSquiggles, marker);
    const { source, pos: end } = extractCursor(sourceWithoutFistSquiggle, marker);
    return { source, pos, end };
}
/**
 * Extracts all identifiers marked with trailing empty comments from source
 */
export function getTestIdentifiers(source) {
    const identifiers = [];
    const ast = parse(source);
    visitChildren(ast, function visit(node) {
        if (node.kind === SyntaxKind.Identifier) {
            if (source.substring(node.end, node.end + "/**/".length) === "/**/") {
                identifiers.push(node);
            }
        }
        visitChildren(node, visit);
    });
    identifiers.sort((x, y) => x.pos - y.pos);
    return identifiers;
}
//# sourceMappingURL=test-server-host.js.map