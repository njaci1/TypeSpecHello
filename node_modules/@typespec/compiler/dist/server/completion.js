import { CompletionItemKind, CompletionItemTag, MarkupKind, TextEdit, } from "vscode-languageserver";
import { SyntaxKind, } from "../core/index.js";
import { getAnyExtensionFromPath, getBaseFileName, getDirectoryPath, hasTrailingDirectorySeparator, resolvePath, } from "../core/path-utils.js";
import { findProjectRoot, loadFile, resolveTspMain } from "../core/util.js";
import { printId } from "../formatter/print/printer.js";
import { isDeprecated } from "../lib/decorators.js";
import { getTypeDetails } from "./type-details.js";
export async function resolveCompletion(context, node) {
    const completions = {
        isIncomplete: false,
        items: [],
    };
    if (node === undefined) {
        addKeywordCompletion("root", completions);
    }
    else {
        switch (node.kind) {
            case SyntaxKind.NamespaceStatement:
                addKeywordCompletion("namespace", completions);
                break;
            case SyntaxKind.Identifier:
                addIdentifierCompletion(context, node);
                break;
            case SyntaxKind.StringLiteral:
                if (node.parent && node.parent.kind === SyntaxKind.ImportStatement) {
                    await addImportCompletion(context, node);
                }
                break;
        }
    }
    return completions;
}
const keywords = [
    // Root only
    ["import", { root: true }],
    // Root and namespace
    ["using", { root: true, namespace: true }],
    ["model", { root: true, namespace: true }],
    ["scalar", { root: true, namespace: true }],
    ["namespace", { root: true, namespace: true }],
    ["interface", { root: true, namespace: true }],
    ["union", { root: true, namespace: true }],
    ["enum", { root: true, namespace: true }],
    ["alias", { root: true, namespace: true }],
    ["op", { root: true, namespace: true }],
    ["dec", { root: true, namespace: true }],
    ["fn", { root: true, namespace: true }],
    // On model `model Foo <keyword> ...`
    ["extends", { model: true }],
    ["is", { model: true }],
    // On identifier`
    ["true", { identifier: true }],
    ["false", { identifier: true }],
    ["unknown", { identifier: true }],
    ["void", { identifier: true }],
    ["never", { identifier: true }],
    // Modifiers
    ["extern", { root: true, namespace: true }],
];
function addKeywordCompletion(area, completions) {
    const filteredKeywords = keywords.filter(([_, x]) => area in x);
    for (const [keyword] of filteredKeywords) {
        completions.items.push({
            label: keyword,
            kind: CompletionItemKind.Keyword,
        });
    }
}
async function addLibraryImportCompletion({ program, file, completions }, node) {
    const documentPath = file.file.path;
    const projectRoot = await findProjectRoot(program.host, documentPath);
    if (projectRoot !== undefined) {
        const [packagejson] = await loadFile(program.host, resolvePath(projectRoot, "package.json"), JSON.parse, program.reportDiagnostic);
        let dependencies = [];
        if (packagejson.dependencies !== undefined) {
            dependencies = dependencies.concat(Object.keys(packagejson.dependencies));
        }
        if (packagejson.peerDependencies !== undefined) {
            dependencies = dependencies.concat(Object.keys(packagejson.peerDependencies));
        }
        for (const dependency of dependencies) {
            const nodeProjectRoot = resolvePath(projectRoot, "node_modules", dependency);
            const [libPackageJson] = await loadFile(program.host, resolvePath(nodeProjectRoot, "package.json"), JSON.parse, program.reportDiagnostic);
            if (resolveTspMain(libPackageJson) !== undefined) {
                const range = {
                    start: file.file.getLineAndCharacterOfPosition(node.pos + 1),
                    end: file.file.getLineAndCharacterOfPosition(node.end - 1),
                };
                completions.items.push({
                    textEdit: TextEdit.replace(range, dependency),
                    label: dependency,
                    kind: CompletionItemKind.Module,
                });
            }
        }
    }
}
async function addImportCompletion(context, node) {
    if (node.value.startsWith("./") || node.value.startsWith("../")) {
        await addRelativePathCompletion(context, node);
    }
    else if (!node.value.startsWith(".")) {
        await addLibraryImportCompletion(context, node);
    }
}
async function addRelativePathCompletion({ program, completions, file }, node) {
    const documentPath = file.file.path;
    const documentFile = getBaseFileName(documentPath);
    const documentDir = getDirectoryPath(documentPath);
    const nodevalueDir = hasTrailingDirectorySeparator(node.value)
        ? node.value
        : getDirectoryPath(node.value);
    const mainTypeSpec = resolvePath(documentDir, nodevalueDir);
    const files = (await program.host.readDir(mainTypeSpec)).filter((x) => x !== documentFile && x !== "node_modules");
    for (const file of files) {
        const extension = getAnyExtensionFromPath(file);
        switch (extension) {
            case ".tsp":
            case ".js":
            case ".mjs":
                completions.items.push({
                    label: file,
                    commitCharacters: [],
                    kind: CompletionItemKind.File,
                });
                break;
            case "":
                completions.items.push({
                    label: file,
                    commitCharacters: [],
                    kind: CompletionItemKind.Folder,
                });
                break;
        }
    }
}
/**
 * Add completion options for an identifier.
 */
function addIdentifierCompletion({ program, completions }, node) {
    var _a, _b;
    const result = program.checker.resolveCompletions(node);
    if (result.size === 0) {
        return;
    }
    for (const [key, { sym, label }] of result) {
        let kind;
        let deprecated = false;
        const type = (_a = sym.type) !== null && _a !== void 0 ? _a : program.checker.getTypeForNode(sym.declarations[0]);
        if (sym.flags & (131072 /* SymbolFlags.Function */ | 16384 /* SymbolFlags.Decorator */)) {
            kind = CompletionItemKind.Function;
        }
        else if (sym.flags & 4096 /* SymbolFlags.Namespace */ &&
            sym.declarations[0].kind !== SyntaxKind.NamespaceStatement) {
            kind = CompletionItemKind.Module;
        }
        else {
            kind = getCompletionItemKind(program, type);
            deprecated = isDeprecated(program, type);
        }
        const documentation = getTypeDetails(program, type);
        const item = {
            label: label !== null && label !== void 0 ? label : key,
            documentation: documentation
                ? {
                    kind: MarkupKind.Markdown,
                    value: documentation,
                }
                : undefined,
            kind,
            insertText: printId(key),
        };
        if (deprecated) {
            item.tags = [CompletionItemTag.Deprecated];
        }
        completions.items.push(item);
    }
    if (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.kind) === SyntaxKind.TypeReference) {
        addKeywordCompletion("identifier", completions);
    }
}
function getCompletionItemKind(program, target) {
    var _a;
    switch ((_a = target.node) === null || _a === void 0 ? void 0 : _a.kind) {
        case SyntaxKind.EnumStatement:
        case SyntaxKind.UnionStatement:
            return CompletionItemKind.Enum;
        case SyntaxKind.EnumMember:
        case SyntaxKind.UnionVariant:
            return CompletionItemKind.EnumMember;
        case SyntaxKind.AliasStatement:
            return CompletionItemKind.Variable;
        case SyntaxKind.ModelStatement:
            return CompletionItemKind.Class;
        case SyntaxKind.ScalarStatement:
            return CompletionItemKind.Unit;
        case SyntaxKind.ModelProperty:
            return CompletionItemKind.Field;
        case SyntaxKind.OperationStatement:
            return CompletionItemKind.Method;
        case SyntaxKind.NamespaceStatement:
            return CompletionItemKind.Module;
        default:
            return CompletionItemKind.Struct;
    }
}
//# sourceMappingURL=completion.js.map