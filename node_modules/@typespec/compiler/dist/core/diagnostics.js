import { formatLog } from "./logger/index.js";
import { reportDiagnostic } from "./messages.js";
import { NoTarget, SyntaxKind, } from "./types.js";
/**
 * Create a new diagnostics creator.
 * @param diagnostics Map of the potential diagnostics.
 * @param libraryName Optional name of the library if in the scope of a library.
 * @returns @see DiagnosticCreator
 */
export function createDiagnosticCreator(diagnostics, libraryName) {
    const errorMessage = libraryName
        ? `It must match one of the code defined in the library '${libraryName}'`
        : "It must match one of the code defined in the compiler.";
    function createDiagnostic(diagnostic) {
        var _a;
        const diagnosticDef = diagnostics[diagnostic.code];
        if (!diagnosticDef) {
            const codeStr = Object.keys(diagnostics)
                .map((x) => ` - ${x}`)
                .join("\n");
            const code = String(diagnostic.code);
            throw new Error(`Unexpected diagnostic code '${code}'. ${errorMessage}. Defined codes:\n${codeStr}`);
        }
        const message = diagnosticDef.messages[(_a = diagnostic.messageId) !== null && _a !== void 0 ? _a : "default"];
        if (!message) {
            const codeStr = Object.keys(diagnosticDef.messages)
                .map((x) => ` - ${x}`)
                .join("\n");
            const messageId = String(diagnostic.messageId);
            const code = String(diagnostic.code);
            throw new Error(`Unexpected message id '${messageId}'. ${errorMessage} for code '${code}'. Defined codes:\n${codeStr}`);
        }
        const messageStr = typeof message === "string" ? message : message(diagnostic.format);
        return {
            code: libraryName ? `${libraryName}/${String(diagnostic.code)}` : diagnostic.code.toString(),
            severity: diagnosticDef.severity,
            message: messageStr,
            target: diagnostic.target,
        };
    }
    function reportDiagnostic(program, diagnostic) {
        const diag = createDiagnostic(diagnostic);
        program.reportDiagnostic(diag);
    }
    return {
        diagnostics,
        createDiagnostic,
        reportDiagnostic,
    };
}
/**
 * Represents a failure while interpreting a projection.
 */
export class ProjectionError extends Error {
    constructor(message) {
        super(message);
        this.name = "ProjectionError";
    }
}
export function logDiagnostics(diagnostics, logger) {
    for (const diagnostic of diagnostics) {
        logger.log({
            level: diagnostic.severity,
            message: diagnostic.message,
            code: diagnostic.code,
            sourceLocation: getSourceLocation(diagnostic.target),
        });
    }
}
export function formatDiagnostic(diagnostic) {
    return formatLog({
        code: diagnostic.code,
        level: diagnostic.severity,
        message: diagnostic.message,
        sourceLocation: getSourceLocation(diagnostic.target),
    }, { pretty: false });
}
export function createSourceFile(text, path) {
    let lineStarts = undefined;
    return {
        text,
        path,
        getLineStarts,
        getLineAndCharacterOfPosition,
    };
    function getLineStarts() {
        return (lineStarts = lineStarts !== null && lineStarts !== void 0 ? lineStarts : scanLineStarts(text));
    }
    function getLineAndCharacterOfPosition(position) {
        const starts = getLineStarts();
        let line = binarySearch(starts, position);
        // When binarySearch returns < 0 indicating that the value was not found, it
        // returns the bitwise complement of the index where the value would need to
        // be inserted to keep the array sorted. So flipping the bits back to this
        // positive index tells us what the line number would be if we were to
        // create a new line starting at the given position, and subtracting 1 from
        // that therefore gives us the line number we're after.
        if (line < 0) {
            line = ~line - 1;
        }
        return {
            line,
            character: position - starts[line],
        };
    }
}
export function getSourceLocation(target) {
    if (target === NoTarget || target === undefined) {
        return undefined;
    }
    if ("file" in target) {
        return target;
    }
    if (!("kind" in target)) {
        // symbol
        if (target.flags & 524288 /* SymbolFlags.Using */) {
            target = target.symbolSource;
        }
        if (!target.declarations[0]) {
            return createSyntheticSourceLocation();
        }
        return getSourceLocationOfNode(target.declarations[0]);
    }
    else if (typeof target.kind === "number") {
        // node
        return getSourceLocationOfNode(target);
    }
    else {
        // type
        const targetNode = target.node;
        if (targetNode) {
            return getSourceLocationOfNode(targetNode);
        }
        return createSyntheticSourceLocation();
    }
}
function createSyntheticSourceLocation(loc = "<unknown location>") {
    return {
        file: createSourceFile("", loc),
        pos: 0,
        end: 0,
        isSynthetic: true,
    };
}
function getSourceLocationOfNode(node) {
    let root = node;
    while (root.parent !== undefined) {
        root = root.parent;
    }
    if (root.kind !== SyntaxKind.TypeSpecScript && root.kind !== SyntaxKind.JsSourceFile) {
        return createSyntheticSourceLocation(node.flags & 8 /* NodeFlags.Synthetic */
            ? undefined
            : "<unknown location - cannot obtain source location of unbound node - file bug at https://github.com/microsoft/typespec>");
    }
    return {
        file: root.file,
        pos: node.pos,
        end: node.end,
    };
}
/**
 * Verbose output is enabled by default for runs in mocha explorer in VS Code,
 * where the output is nicely associated with the individual test, and disabled
 * by default for command line runs where we don't want to spam the console.
 *
 * If the steps taken to produce the message are expensive, pass a callback
 * instead of producing the message then passing it here only to be dropped
 * when verbose output is disabled.
 */
export function logVerboseTestOutput(messageOrCallback) {
    if (process.env.TYPESPEC_VERBOSE_TEST_OUTPUT) {
        if (typeof messageOrCallback === "string") {
            // eslint-disable-next-line no-console
            console.log(messageOrCallback);
        }
        else {
            // eslint-disable-next-line no-console
            messageOrCallback(console.log);
        }
    }
}
/**
 * Use this to report bugs in the compiler, and not errors in the source code
 * being compiled.
 *
 * @param condition Throw if this is not true.
 *
 * @param message Error message.
 *
 * @param target Optional location in source code that might give a clue about
 *               what got the compiler off track.
 */
export function compilerAssert(condition, message, target) {
    if (condition) {
        return;
    }
    if (target) {
        let location;
        try {
            location = getSourceLocation(target);
        }
        catch (err) { }
        if (location) {
            const pos = location.file.getLineAndCharacterOfPosition(location.pos);
            const file = location.file.path;
            const line = pos.line + 1;
            const col = pos.character + 1;
            message += `\nOccurred while compiling code in ${file} near line ${line}, column ${col}`;
        }
    }
    throw new Error(message);
}
function scanLineStarts(text) {
    const starts = [];
    let start = 0;
    let pos = 0;
    while (pos < text.length) {
        const ch = text.charCodeAt(pos);
        pos++;
        switch (ch) {
            case 13 /* CharCode.CarriageReturn */:
                if (text.charCodeAt(pos) === 10 /* CharCode.LineFeed */) {
                    pos++;
                }
            // fallthrough
            case 10 /* CharCode.LineFeed */:
                starts.push(start);
                start = pos;
                break;
        }
    }
    starts.push(start);
    return starts;
}
/**
 * Search sorted array of numbers for the given value. If found, return index
 * in array where value was found. If not found, return a negative number that
 * is the bitwise complement of the index where value would need to be inserted
 * to keep the array sorted.
 */
function binarySearch(array, value) {
    let low = 0;
    let high = array.length - 1;
    while (low <= high) {
        const middle = low + ((high - low) >> 1);
        const v = array[middle];
        if (v < value) {
            low = middle + 1;
        }
        else if (v > value) {
            high = middle - 1;
        }
        else {
            return middle;
        }
    }
    return ~low;
}
/**
 * Assert that the input type has one of the kinds provided
 */
export function assertType(typeDescription, t, ...kinds) {
    if (kinds.indexOf(t.kind) === -1) {
        throw new ProjectionError(`Expected ${typeDescription} to be type ${kinds.join(", ")}`);
    }
}
/**
 * Report a deprecated diagnostic.
 * @param program TypeSpec Program.
 * @param message Message describing the deprecation.
 * @param target Target of the deprecation.
 */
export function reportDeprecated(program, message, target) {
    reportDiagnostic(program, {
        code: "deprecated",
        format: {
            message,
        },
        target,
    });
}
/**
 * Create a new instance of the @see DiagnosticCollector.
 */
export function createDiagnosticCollector() {
    const diagnostics = [];
    return {
        diagnostics,
        add,
        pipe,
        wrap,
    };
    function add(diagnostic) {
        diagnostics.push(diagnostic);
    }
    function pipe(result) {
        const [value, diags] = result;
        for (const diag of diags) {
            diagnostics.push(diag);
        }
        return value;
    }
    function wrap(value) {
        return [value, diagnostics];
    }
}
/**
 * Ignore the diagnostics emitted by the diagnostic accessor pattern and just return the actual result.
 * @param result: Accessor pattern tuple result including the actual result and the list of diagnostics.
 * @returns Actual result.
 */
export function ignoreDiagnostics(result) {
    return result[0];
}
//# sourceMappingURL=diagnostics.js.map