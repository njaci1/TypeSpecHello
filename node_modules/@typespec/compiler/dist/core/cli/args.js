import { expandConfigVariables } from "../../config/config-interpolation.js";
import { loadTypeSpecConfigForPath, validateConfigPathsAbsolute, } from "../../config/config-loader.js";
import { createDiagnosticCollector } from "../index.js";
import { normalizePath, resolvePath } from "../path-utils.js";
import { deepClone, omitUndefined } from "../util.js";
export async function getCompilerOptions(host, cwd, args, env) {
    var _a, _b, _c, _d, _e, _f;
    cwd = normalizePath(cwd);
    const diagnostics = createDiagnosticCollector();
    const pathArg = (_a = args["output-dir"]) !== null && _a !== void 0 ? _a : args["output-path"];
    const configPath = (_b = args["config"]) !== null && _b !== void 0 ? _b : cwd;
    const config = await loadTypeSpecConfigForPath(host, configPath, "config" in args);
    if (config.diagnostics.length > 0) {
        if (config.diagnostics.some((d) => d.severity === "error")) {
            return [undefined, config.diagnostics];
        }
        config.diagnostics.forEach((x) => diagnostics.add(x));
    }
    const cliOptions = resolveCliOptions(args);
    const configWithCliArgs = {
        ...config,
        outputDir: config.outputDir,
        imports: (_c = args["import"]) !== null && _c !== void 0 ? _c : config["imports"],
        warnAsError: (_d = args["warn-as-error"]) !== null && _d !== void 0 ? _d : config.warnAsError,
        trace: (_e = args.trace) !== null && _e !== void 0 ? _e : config.trace,
        emit: (_f = args.emit) !== null && _f !== void 0 ? _f : config.emit,
        options: resolveEmitterOptions(config, cliOptions),
    };
    const cliOutputDir = pathArg ? resolvePath(cwd, pathArg) : undefined;
    const expandedConfig = diagnostics.pipe(expandConfigVariables(configWithCliArgs, {
        cwd: cwd,
        outputDir: cliOutputDir,
        env,
        args: resolveConfigArgs(args),
    }));
    validateConfigPathsAbsolute(expandedConfig).forEach((x) => diagnostics.add(x));
    const options = omitUndefined({
        nostdlib: args["nostdlib"],
        watchForChanges: args["watch"],
        noEmit: args["no-emit"],
        miscOptions: cliOptions.miscOptions,
        outputDir: expandedConfig.outputDir,
        config: config.filename,
        additionalImports: expandedConfig["imports"],
        warningAsError: expandedConfig.warnAsError,
        trace: expandedConfig.trace,
        emit: expandedConfig.emit,
        options: expandedConfig.options,
    });
    return diagnostics.wrap(options);
}
function resolveConfigArgs(args) {
    var _a;
    const map = {};
    for (const arg of (_a = args.args) !== null && _a !== void 0 ? _a : []) {
        const optionParts = arg.split("=");
        if (optionParts.length !== 2) {
            throw new Error(`The --arg parameter value "${arg}" must be in the format: arg-name=value`);
        }
        map[optionParts[0]] = optionParts[1];
    }
    return map;
}
function resolveCliOptions(args) {
    var _a;
    const options = {};
    for (const option of (_a = args.options) !== null && _a !== void 0 ? _a : []) {
        const optionParts = option.split("=");
        if (optionParts.length !== 2) {
            throw new Error(`The --option parameter value "${option}" must be in the format: <emitterName>.some-options=value`);
        }
        let optionKeyParts = optionParts[0].split(".");
        if (optionKeyParts.length === 1) {
            const key = optionKeyParts[0];
            if (!("miscOptions" in options)) {
                options.miscOptions = {};
            }
            options.miscOptions[key] = optionParts[1];
            continue;
        }
        else if (optionKeyParts.length > 2) {
            // support emitter/path/file.js.option=xyz
            optionKeyParts = [
                optionKeyParts.slice(0, -1).join("."),
                optionKeyParts[optionKeyParts.length - 1],
            ];
        }
        const emitterName = optionKeyParts[0];
        const key = optionKeyParts[1];
        if (!(emitterName in options)) {
            options[emitterName] = {};
        }
        options[emitterName][key] = optionParts[1];
    }
    return options;
}
function resolveEmitterOptions(config, cliOptions) {
    var _a, _b;
    const configuredEmitters = deepClone((_a = config.options) !== null && _a !== void 0 ? _a : {});
    for (const [emitterName, cliOptionOverride] of Object.entries(cliOptions)) {
        if (emitterName === "miscOptions") {
            continue;
        }
        configuredEmitters[emitterName] = {
            ...((_b = configuredEmitters[emitterName]) !== null && _b !== void 0 ? _b : {}),
            ...cliOptionOverride,
        };
    }
    return configuredEmitters;
}
//# sourceMappingURL=args.js.map