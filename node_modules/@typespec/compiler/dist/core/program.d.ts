import { Checker } from "./checker.js";
import { CompilerOptions } from "./options.js";
import { CompilerHost, Diagnostic, EmitterFunc, JsSourceFileNode, LiteralType, Namespace, ProjectionApplication, Projector, SourceFile, SymbolTable, Tracer, Type, TypeSpecScriptNode } from "./types.js";
export interface ProjectedProgram extends Program {
    projector: Projector;
}
export declare function isProjectedProgram(program: Program | ProjectedProgram): program is ProjectedProgram;
export interface Program {
    compilerOptions: CompilerOptions;
    mainFile?: TypeSpecScriptNode;
    /** All source files in the program, keyed by their file path. */
    sourceFiles: Map<string, TypeSpecScriptNode>;
    jsSourceFiles: Map<string, JsSourceFileNode>;
    literalTypes: Map<string | number | boolean, LiteralType>;
    host: CompilerHost;
    tracer: Tracer;
    trace(area: string, message: string): void;
    checker: Checker;
    emitters: EmitterRef[];
    readonly diagnostics: readonly Diagnostic[];
    loadTypeSpecScript(typespecScript: SourceFile): Promise<TypeSpecScriptNode>;
    onValidate(cb: (program: Program) => void | Promise<void>): void;
    getOption(key: string): string | undefined;
    stateSet(key: symbol): Set<Type>;
    stateSets: Map<symbol, StateSet>;
    stateMap(key: symbol): Map<Type, any>;
    stateMaps: Map<symbol, StateMap>;
    hasError(): boolean;
    reportDiagnostic(diagnostic: Diagnostic): void;
    reportDiagnostics(diagnostics: readonly Diagnostic[]): void;
    reportDuplicateSymbols(symbols: SymbolTable | undefined): void;
    getGlobalNamespaceType(): Namespace;
    resolveTypeReference(reference: string): [Type | undefined, readonly Diagnostic[]];
    /**
     * Project root. If a tsconfig was found/specified this is the directory for the tsconfig.json. Otherwise directory where the entrypoint is located.
     */
    readonly projectRoot: string;
}
interface LibraryMetadata {
    /**
     * Library name as specified in the package.json or in exported $lib.
     */
    name?: string;
    /**
     * Library homepage.
     */
    homepage?: string;
    bugs?: {
        /**
         * Url where to file bugs for this library.
         */
        url?: string;
    };
}
interface EmitterRef {
    emitFunction: EmitterFunc;
    main: string;
    metadata: LibraryMetadata;
    emitterOutputDir: string;
    options: Record<string, unknown>;
}
declare class StateMap extends Map<undefined | Projector, Map<Type, unknown>> {
}
declare class StateSet extends Map<undefined | Projector, Set<Type>> {
}
declare class StateMapView<V> implements Map<Type, V> {
    private state;
    private projector?;
    constructor(state: StateMap, projector?: Projector | undefined);
    has(t: Type): boolean;
    set(t: Type, v: any): this;
    get(t: Type): V | undefined;
    delete(t: Type): boolean;
    forEach(cb: (value: V, key: Type, map: Map<Type, V>) => void, thisArg?: any): this;
    get size(): number;
    clear(): void;
    entries(): IterableIterator<[Type, V]>;
    values(): IterableIterator<V>;
    keys(): IterableIterator<Type>;
    [Symbol.iterator](): IterableIterator<[Type, V]>;
    [Symbol.toStringTag]: string;
    dispatch(keyType?: Type): Map<Type, V>;
}
declare class StateSetView implements Set<Type> {
    private state;
    private projector?;
    constructor(state: StateSet, projector?: Projector | undefined);
    has(t: Type): boolean;
    add(t: Type): this;
    delete(t: Type): boolean;
    forEach(cb: (value: Type, value2: Type, set: Set<Type>) => void, thisArg?: any): this;
    get size(): number;
    clear(): void;
    values(): IterableIterator<Type>;
    keys(): IterableIterator<Type>;
    entries(): IterableIterator<[Type, Type]>;
    [Symbol.iterator](): IterableIterator<Type>;
    [Symbol.toStringTag]: string;
    dispatch(keyType?: Type): Set<Type>;
}
export declare function projectProgram(program: Program, projections: ProjectionApplication[], startNode?: Type): ProjectedProgram;
export declare function compile(host: CompilerHost, mainFile: string, options?: CompilerOptions, oldProgram?: Program): Promise<Program>;
export declare function createStateAccessors(stateMaps: Map<symbol, StateMap>, stateSets: Map<symbol, StateSet>, projector?: Projector): {
    stateMap: <T>(key: symbol) => StateMapView<T>;
    stateSet: (key: symbol) => StateSetView;
};
export {};
//# sourceMappingURL=program.d.ts.map