import { printId } from "../../formatter/print/printer.js";
import { isTemplateInstance } from "../type-utils.js";
export function getTypeName(type, options) {
    switch (type.kind) {
        case "Namespace":
            return getNamespaceFullName(type, options);
        case "TemplateParameter":
            return getIdentifierName(type.node.id.sv, options);
        case "Scalar":
            return getScalarName(type, options);
        case "Model":
            return getModelName(type, options);
        case "ModelProperty":
            return getModelPropertyName(type, options);
        case "Interface":
            return getInterfaceName(type, options);
        case "Operation":
            return getOperationName(type, options);
        case "Enum":
            return getEnumName(type, options);
        case "EnumMember":
            return `${getEnumName(type.enum, options)}.${getIdentifierName(type.name, options)}`;
        case "Union":
            return type.name
                ? getIdentifierName(type.name, options)
                : [...type.variants.values()].map((x) => getTypeName(x.type, options)).join(" | ");
        case "UnionVariant":
            return getTypeName(type.type, options);
        case "Tuple":
            return "[" + type.values.map((x) => getTypeName(x, options)).join(", ") + "]";
        case "String":
        case "Number":
        case "Boolean":
            return type.value.toString();
        case "Intrinsic":
            return type.name;
    }
    return "(unnamed type)";
}
export function isStdNamespace(namespace) {
    var _a, _b, _c, _d;
    return ((namespace.name === "TypeSpec" && ((_a = namespace.namespace) === null || _a === void 0 ? void 0 : _a.name) === "") ||
        (namespace.name === "Reflection" &&
            ((_b = namespace.namespace) === null || _b === void 0 ? void 0 : _b.name) === "TypeSpec" &&
            ((_d = (_c = namespace.namespace) === null || _c === void 0 ? void 0 : _c.namespace) === null || _d === void 0 ? void 0 : _d.name) === ""));
}
/**
 * Return the full name of the namespace(e.g. "Foo.Bar")
 * @param type namespace type
 * @param options
 * @returns
 */
export function getNamespaceFullName(type, options) {
    const filter = options === null || options === void 0 ? void 0 : options.namespaceFilter;
    const segments = [];
    let current = type;
    while (current && current.name !== "") {
        if (filter && !filter(current)) {
            break;
        }
        segments.unshift(getIdentifierName(current.name, options));
        current = current.namespace;
    }
    return segments.join(".");
}
function getNamespacePrefix(type, options) {
    if (type === undefined || isStdNamespace(type)) {
        return "";
    }
    const namespaceFullName = getNamespaceFullName(type, options);
    return namespaceFullName !== "" ? namespaceFullName + "." : "";
}
function getEnumName(e, options) {
    return `${getNamespacePrefix(e.namespace, options)}${getIdentifierName(e.name, options)}`;
}
function getScalarName(scalar, options) {
    return `${getNamespacePrefix(scalar.namespace, options)}${getIdentifierName(scalar.name, options)}`;
}
function getModelName(model, options) {
    var _a, _b;
    const nsPrefix = getNamespacePrefix(model.namespace, options);
    if (model.name === "" && model.properties.size === 0) {
        return "{}";
    }
    if (model.indexer && model.indexer.key.kind === "Scalar") {
        if (model.name === "Array" && isInTypeSpecNamespace(model)) {
            return `${getTypeName(model.indexer.value, options)}[]`;
        }
    }
    if (model.name === "") {
        return nsPrefix + "(anonymous model)";
    }
    const modelName = nsPrefix + getIdentifierName(model.name, options);
    if (isTemplateInstance(model)) {
        // template instantiation
        const args = model.templateMapper.args.map((x) => getTypeName(x, options));
        return `${modelName}<${args.join(", ")}>`;
    }
    else if (((_b = (_a = model.node) === null || _a === void 0 ? void 0 : _a.templateParameters) === null || _b === void 0 ? void 0 : _b.length) > 0) {
        // template
        const params = model.node.templateParameters.map((t) => getIdentifierName(t.id.sv, options));
        return `${modelName}<${params.join(", ")}>`;
    }
    else {
        // regular old model.
        return modelName;
    }
}
/**
 * Check if the given namespace is the standard library `TypeSpec` namespace.
 */
function isTypeSpecNamespace(namespace) {
    var _a;
    return namespace.name === "TypeSpec" && ((_a = namespace.namespace) === null || _a === void 0 ? void 0 : _a.name) === "";
}
/**
 * Check if the given type is defined right in the TypeSpec namespace.
 */
function isInTypeSpecNamespace(type) {
    return Boolean(type.namespace && isTypeSpecNamespace(type.namespace));
}
function getModelPropertyName(prop, options) {
    const modelName = prop.model ? getModelName(prop.model, options) : undefined;
    return `${modelName !== null && modelName !== void 0 ? modelName : "(anonymous model)"}.${prop.name}`;
}
function getInterfaceName(iface, options) {
    let interfaceName = getIdentifierName(iface.name, options);
    if (isTemplateInstance(iface)) {
        interfaceName += `<${iface.templateMapper.args
            .map((x) => getTypeName(x, options))
            .join(", ")}>`;
    }
    return `${getNamespacePrefix(iface.namespace, options)}${interfaceName}`;
}
function getOperationName(op, options) {
    return `${getNamespacePrefix(op.namespace, options)}${getIdentifierName(op.name, options)}`;
}
function getIdentifierName(name, options) {
    return (options === null || options === void 0 ? void 0 : options.printable) ? printId(name) : name;
}
//# sourceMappingURL=type-name-utils.js.map