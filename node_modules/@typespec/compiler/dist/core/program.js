var _a, _b;
import { createAssetEmitter } from "../emitter-framework/asset-emitter.js";
import { createBinder } from "./binder.js";
import { createChecker } from "./checker.js";
import { compilerAssert, createSourceFile } from "./diagnostics.js";
import { getLibraryUrlsLoaded } from "./library.js";
import { createLogger } from "./logger/index.js";
import { createTracer } from "./logger/tracer.js";
import { MANIFEST } from "./manifest.js";
import { createDiagnostic } from "./messages.js";
import { resolveModule, } from "./module-resolver.js";
import { isImportStatement, parse, parseStandaloneTypeReference } from "./parser.js";
import { getDirectoryPath, joinPaths, resolvePath } from "./path-utils.js";
import { createProjector } from "./projector.js";
import { NoTarget, SyntaxKind, } from "./types.js";
import { ExternalError, deepEquals, doIO, findProjectRoot, isDefined, loadFile, mapEquals, mutate, resolveTspMain, } from "./util.js";
export function isProjectedProgram(program) {
    return "projector" in program;
}
class StateMap extends Map {
}
class StateSet extends Map {
}
class StateMapView {
    constructor(state, projector) {
        this.state = state;
        this.projector = projector;
        this[_a] = "StateMap";
    }
    has(t) {
        var _c, _d;
        return (_d = (_c = this.dispatch(t)) === null || _c === void 0 ? void 0 : _c.has(t)) !== null && _d !== void 0 ? _d : false;
    }
    set(t, v) {
        this.dispatch(t).set(t, v);
        return this;
    }
    get(t) {
        return this.dispatch(t).get(t);
    }
    delete(t) {
        return this.dispatch(t).delete(t);
    }
    forEach(cb, thisArg) {
        this.dispatch().forEach(cb, thisArg);
        return this;
    }
    get size() {
        return this.dispatch().size;
    }
    clear() {
        return this.dispatch().clear();
    }
    entries() {
        return this.dispatch().entries();
    }
    values() {
        return this.dispatch().values();
    }
    keys() {
        return this.dispatch().keys();
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    dispatch(keyType) {
        const key = keyType ? keyType.projector : this.projector;
        if (!this.state.has(key)) {
            this.state.set(key, new Map());
        }
        return this.state.get(key);
    }
}
_a = Symbol.toStringTag;
class StateSetView {
    constructor(state, projector) {
        this.state = state;
        this.projector = projector;
        this[_b] = "StateSet";
    }
    has(t) {
        var _c, _d;
        return (_d = (_c = this.dispatch(t)) === null || _c === void 0 ? void 0 : _c.has(t)) !== null && _d !== void 0 ? _d : false;
    }
    add(t) {
        this.dispatch(t).add(t);
        return this;
    }
    delete(t) {
        return this.dispatch(t).delete(t);
    }
    forEach(cb, thisArg) {
        this.dispatch().forEach(cb, thisArg);
        return this;
    }
    get size() {
        return this.dispatch().size;
    }
    clear() {
        return this.dispatch().clear();
    }
    values() {
        return this.dispatch().values();
    }
    keys() {
        return this.dispatch().keys();
    }
    entries() {
        return this.dispatch().entries();
    }
    [Symbol.iterator]() {
        return this.values();
    }
    dispatch(keyType) {
        const key = keyType ? keyType.projector : this.projector;
        if (!this.state.has(key)) {
            this.state.set(key, new Set());
        }
        return this.state.get(key);
    }
}
_b = Symbol.toStringTag;
export function projectProgram(program, projections, startNode) {
    return createProjector(program, projections, startNode);
}
export async function compile(host, mainFile, options = {}, oldProgram // NOTE: deliberately separate from options to avoid memory leak by chaining all old programs together.
) {
    var _c, _d;
    const validateCbs = [];
    const stateMaps = new Map();
    const stateSets = new Map();
    const diagnostics = [];
    const seenSourceFiles = new Set();
    const duplicateSymbols = new Set();
    const emitters = [];
    const requireImports = new Map();
    const loadedLibraries = new Map();
    let error = false;
    const logger = createLogger({ sink: host.logSink });
    const tracer = createTracer(logger, { filter: options.trace });
    const resolvedMain = await resolveTypeSpecEntrypoint(mainFile);
    const program = {
        checker: undefined,
        compilerOptions: resolveOptions(options),
        sourceFiles: new Map(),
        jsSourceFiles: new Map(),
        literalTypes: new Map(),
        host,
        diagnostics,
        emitters,
        loadTypeSpecScript,
        getOption,
        stateMaps,
        stateSets,
        tracer,
        trace,
        ...createStateAccessors(stateMaps, stateSets),
        reportDiagnostic,
        reportDiagnostics,
        reportDuplicateSymbols,
        hasError() {
            return error;
        },
        onValidate(cb) {
            validateCbs.push(cb);
        },
        getGlobalNamespaceType,
        resolveTypeReference,
        projectRoot: getDirectoryPath((_d = (_c = options.config) !== null && _c !== void 0 ? _c : resolvedMain) !== null && _d !== void 0 ? _d : ""),
    };
    trace("compiler.options", JSON.stringify(options, null, 2));
    function trace(area, message) {
        tracer.trace(area, message);
    }
    const binder = createBinder(program);
    if (!(options === null || options === void 0 ? void 0 : options.nostdlib)) {
        await loadStandardLibrary(program);
    }
    // Load additional imports prior to compilation
    if (resolvedMain && options.additionalImports) {
        const importScript = options.additionalImports.map((i) => `import "${i}";`).join("\n");
        const sourceFile = createSourceFile(importScript, joinPaths(getDirectoryPath(resolvedMain), `__additional_imports`));
        await loadTypeSpecScript(sourceFile);
    }
    if (resolvedMain) {
        await loadMain(resolvedMain, options);
    }
    if (resolvedMain) {
        let emit = options.emit;
        let emitterOptions = options.options;
        /* eslint-disable deprecation/deprecation */
        if (options.emitters) {
            emit !== null && emit !== void 0 ? emit : (emit = Object.keys(options.emitters));
            emitterOptions !== null && emitterOptions !== void 0 ? emitterOptions : (emitterOptions = options.emitters);
        }
        /* eslint-enable deprecation/deprecation */
        await loadEmitters(resolvedMain, emit !== null && emit !== void 0 ? emit : [], emitterOptions !== null && emitterOptions !== void 0 ? emitterOptions : {});
    }
    if (oldProgram &&
        mapEquals(oldProgram.sourceFiles, program.sourceFiles) &&
        deepEquals(oldProgram.compilerOptions, program.compilerOptions)) {
        return oldProgram;
    }
    // let GC reclaim old program, we do not reuse it beyond this point.
    oldProgram = undefined;
    program.checker = createChecker(program);
    program.checker.checkProgram();
    if (program.hasError()) {
        return program;
    }
    for (const cb of validateCbs) {
        try {
            await cb(program);
        }
        catch (error) {
            if (options.designTimeBuild) {
                program.reportDiagnostic(createDiagnostic({
                    code: "on-validate-fail",
                    format: { error: error.stack },
                    target: NoTarget,
                }));
            }
            else {
                throw error;
            }
        }
    }
    for (const [requiredImport, emitterName] of requireImports) {
        if (!loadedLibraries.has(requiredImport)) {
            program.reportDiagnostic(createDiagnostic({
                code: "missing-import",
                format: { requiredImport, emitterName },
                target: NoTarget,
            }));
        }
    }
    await validateLoadedLibraries();
    if (program.hasError()) {
        return program;
    }
    for (const instance of emitters) {
        await runEmitter(instance);
    }
    return program;
    /**
     * Validate the libraries loaded during the compilation process are compatible.
     */
    async function validateLoadedLibraries() {
        const loadedRoots = new Set();
        // Check all the files that were loaded
        for (const fileUrl of getLibraryUrlsLoaded()) {
            const root = await findProjectRoot(host, host.fileURLToPath(fileUrl));
            if (root) {
                loadedRoots.add(root);
            }
        }
        const libraries = new Map([...loadedLibraries.entries()]);
        const incompatibleLibraries = new Map();
        for (const root of loadedRoots) {
            const packageJsonPath = joinPaths(root, "package.json");
            try {
                const packageJson = JSON.parse((await host.readFile(packageJsonPath)).text);
                const found = libraries.get(packageJson.name);
                if (found && found.path !== root && found.manifest.version !== packageJson.version) {
                    let incompatibleIndex = incompatibleLibraries.get(packageJson.name);
                    if (incompatibleIndex === undefined) {
                        incompatibleIndex = [found];
                        incompatibleLibraries.set(packageJson.name, incompatibleIndex);
                    }
                    incompatibleIndex.push({ path: root, manifest: packageJson });
                }
            }
            catch { }
        }
        for (const [name, incompatibleLibs] of incompatibleLibraries) {
            reportDiagnostic(createDiagnostic({
                code: "incompatible-library",
                format: {
                    name: name,
                    versionMap: incompatibleLibs
                        .map((x) => `  - Version: "${x.manifest.version}" installed at "${x.path}"`)
                        .join("\n"),
                },
                target: NoTarget,
            }));
        }
    }
    async function loadStandardLibrary(program) {
        for (const dir of host.getLibDirs()) {
            await loadDirectory(dir, NoTarget);
        }
    }
    async function loadDirectory(dir, diagnosticTarget) {
        const mainFile = await resolveTypeSpecEntrypointForDir(dir);
        await loadTypeSpecFile(mainFile, diagnosticTarget);
        return mainFile;
    }
    async function loadTypeSpecFile(path, diagnosticTarget) {
        if (seenSourceFiles.has(path)) {
            return;
        }
        seenSourceFiles.add(path);
        const file = await doIO(host.readFile, path, program.reportDiagnostic, {
            diagnosticTarget,
        });
        if (file) {
            await loadTypeSpecScript(file);
        }
    }
    async function loadJsFile(path, diagnosticTarget) {
        const sourceFile = program.jsSourceFiles.get(path);
        if (sourceFile !== undefined) {
            return sourceFile;
        }
        const file = createSourceFile("", path);
        const exports = await doIO(host.getJsImport, path, program.reportDiagnostic, {
            diagnosticTarget,
            jsDiagnosticTarget: { file, pos: 0, end: 0 },
        });
        if (!exports) {
            return undefined;
        }
        return {
            kind: SyntaxKind.JsSourceFile,
            id: {
                kind: SyntaxKind.Identifier,
                sv: "",
                pos: 0,
                end: 0,
                symbol: undefined,
                flags: 8 /* NodeFlags.Synthetic */,
            },
            esmExports: exports,
            file,
            namespaceSymbols: [],
            symbol: undefined,
            pos: 0,
            end: 0,
            flags: 0 /* NodeFlags.None */,
        };
    }
    /**
     * Import the Javascript files decorator and lifecycle hooks.
     */
    async function importJsFile(path, diagnosticTarget) {
        const file = await loadJsFile(path, diagnosticTarget);
        if (file !== undefined) {
            program.jsSourceFiles.set(path, file);
            binder.bindJsSourceFile(file);
        }
    }
    async function loadTypeSpecScript(file) {
        // This is not a diagnostic because the compiler should never reuse the same path.
        // It's the caller's responsibility to use unique paths.
        if (program.sourceFiles.has(file.path)) {
            throw new RangeError("Duplicate script path: " + file.path);
        }
        const script = parseOrReuse(file);
        program.reportDiagnostics(script.parseDiagnostics);
        program.sourceFiles.set(file.path, script);
        binder.bindSourceFile(script);
        await loadScriptImports(script);
        return script;
    }
    function parseOrReuse(file) {
        var _c, _d, _e;
        const old = (_c = oldProgram === null || oldProgram === void 0 ? void 0 : oldProgram.sourceFiles.get(file.path)) !== null && _c !== void 0 ? _c : (_d = host === null || host === void 0 ? void 0 : host.parseCache) === null || _d === void 0 ? void 0 : _d.get(file);
        if ((old === null || old === void 0 ? void 0 : old.file) === file && deepEquals(old.parseOptions, options.parseOptions)) {
            return old;
        }
        const script = parse(file, options.parseOptions);
        (_e = host.parseCache) === null || _e === void 0 ? void 0 : _e.set(file, script);
        return script;
    }
    async function loadScriptImports(file) {
        // collect imports
        const basedir = getDirectoryPath(file.file.path);
        await loadImports(file.statements.filter(isImportStatement).map((x) => ({ path: x.path.value, target: x })), basedir);
    }
    async function loadImports(imports, relativeTo) {
        // collect imports
        for (const { path, target } of imports) {
            await loadImport(path, target, relativeTo);
        }
    }
    async function loadImport(path, target, relativeTo) {
        const library = await resolveTypeSpecLibrary(path, relativeTo, target);
        if (library === undefined) {
            return;
        }
        if (library.type === "module") {
            loadedLibraries.set(library.manifest.name, {
                path: library.path,
                manifest: library.manifest,
            });
            trace("import-resolution.library", `Loading library "${path}" from "${library.mainFile}"`);
        }
        const importFilePath = library.type === "module" ? library.mainFile : library.path;
        const isDirectory = (await host.stat(importFilePath)).isDirectory();
        if (isDirectory) {
            return await loadDirectory(importFilePath, target);
        }
        const sourceFileKind = host.getSourceFileKind(importFilePath);
        switch (sourceFileKind) {
            case "js":
                return await importJsFile(importFilePath, target);
            case "typespec":
                return await loadTypeSpecFile(importFilePath, target);
            default:
                program.reportDiagnostic(createDiagnostic({ code: "invalid-import", target }));
        }
    }
    async function loadEmitters(mainFile, emitterNameOrPaths, emitterOptions) {
        var _c;
        const emitterThatShouldExists = new Set(Object.keys(emitterOptions));
        for (const emitterNameOrPath of emitterNameOrPaths) {
            const emitter = await loadEmitter(mainFile, emitterNameOrPath, emitterOptions);
            if (emitter) {
                emitters.push(emitter);
                emitterThatShouldExists.delete((_c = emitter.metadata.name) !== null && _c !== void 0 ? _c : emitterNameOrPath);
            }
        }
        // This is the emitter names under options that haven't been used. We need to check if it points to an emitter that wasn't loaded
        for (const emitterName of emitterThatShouldExists) {
            // attempt to resolve a node module with this name
            const [module, _] = await resolveEmitterModuleAndEntrypoint(mainFile, emitterName);
            if ((module === null || module === void 0 ? void 0 : module.entrypoint) === undefined) {
                program.reportDiagnostic(createDiagnostic({
                    code: "emitter-not-found",
                    format: { emitterName },
                    target: NoTarget,
                }));
            }
        }
    }
    async function resolveEmitterModuleAndEntrypoint(mainFile, emitterNameOrPath) {
        const basedir = getDirectoryPath(mainFile);
        // attempt to resolve a node module with this name
        const [module, diagnostics] = await resolveJSLibrary(emitterNameOrPath, basedir);
        if (!module) {
            return [undefined, diagnostics];
        }
        const entrypoint = module.type === "file" ? module.path : module.mainFile;
        const file = await loadJsFile(entrypoint, NoTarget);
        return [{ module, entrypoint: file }, []];
    }
    async function loadEmitter(mainFile, emitterNameOrPath, emittersOptions) {
        var _c, _d, _e, _f;
        const [resolution, diagnostics] = await resolveEmitterModuleAndEntrypoint(mainFile, emitterNameOrPath);
        if (resolution === undefined) {
            program.reportDiagnostics(diagnostics);
            return undefined;
        }
        const { module, entrypoint } = resolution;
        if (entrypoint === undefined) {
            program.reportDiagnostic(createDiagnostic({
                code: "invalid-emitter",
                format: { emitterPackage: emitterNameOrPath },
                target: NoTarget,
            }));
            return undefined;
        }
        const emitFunction = entrypoint.esmExports.$onEmit;
        const libDefinition = entrypoint.esmExports.$lib;
        const metadata = computeLibraryMetadata(module, libDefinition);
        let { "emitter-output-dir": emitterOutputDir, ...emitterOptions } = (_d = emittersOptions[(_c = metadata.name) !== null && _c !== void 0 ? _c : emitterNameOrPath]) !== null && _d !== void 0 ? _d : {};
        if (emitterOutputDir === undefined) {
            emitterOutputDir = [options.outputDir, metadata.name].filter(isDefined).join("/");
        }
        if (libDefinition === null || libDefinition === void 0 ? void 0 : libDefinition.requireImports) {
            for (const lib of libDefinition.requireImports) {
                requireImports.set(lib, libDefinition.name);
            }
        }
        if (emitFunction !== undefined) {
            if ((_e = libDefinition === null || libDefinition === void 0 ? void 0 : libDefinition.emitter) === null || _e === void 0 ? void 0 : _e.options) {
                const diagnostics = (_f = libDefinition === null || libDefinition === void 0 ? void 0 : libDefinition.emitterOptionValidator) === null || _f === void 0 ? void 0 : _f.validate(emitterOptions, NoTarget);
                if (diagnostics && diagnostics.length > 0) {
                    program.reportDiagnostics(diagnostics);
                    return;
                }
            }
            return {
                main: entrypoint.file.path,
                emitFunction,
                metadata,
                emitterOutputDir,
                options: emitterOptions,
            };
        }
        else {
            program.reportDiagnostic(createDiagnostic({
                code: "invalid-emitter",
                format: { emitterPackage: emitterNameOrPath },
                target: NoTarget,
            }));
            return undefined;
        }
    }
    function computeLibraryMetadata(module, libDefinition) {
        var _c, _d, _e;
        if (module.type === "file") {
            return {
                name: libDefinition === null || libDefinition === void 0 ? void 0 : libDefinition.name,
            };
        }
        const metadata = {
            name: (_c = libDefinition === null || libDefinition === void 0 ? void 0 : libDefinition.name) !== null && _c !== void 0 ? _c : module.manifest.name,
        };
        if (module.manifest.homepage) {
            metadata.homepage = module.manifest.homepage;
        }
        if ((_d = module.manifest.bugs) === null || _d === void 0 ? void 0 : _d.url) {
            metadata.bugs = { url: (_e = module.manifest.bugs) === null || _e === void 0 ? void 0 : _e.url };
        }
        return metadata;
    }
    /**
     * @param emitter Emitter ref to run
     */
    async function runEmitter(emitter) {
        var _c, _d, _e;
        const context = {
            program,
            emitterOutputDir: emitter.emitterOutputDir,
            options: emitter.options,
            getAssetEmitter(TypeEmitterClass) {
                return createAssetEmitter(program, TypeEmitterClass, this);
            },
        };
        try {
            await emitter.emitFunction(context);
        }
        catch (error) {
            const msg = [`Emitter "${(_c = emitter.metadata.name) !== null && _c !== void 0 ? _c : emitter.main}" failed!`];
            if ((_d = emitter.metadata.bugs) === null || _d === void 0 ? void 0 : _d.url) {
                msg.push(`File issue at ${(_e = emitter.metadata.bugs) === null || _e === void 0 ? void 0 : _e.url}`);
            }
            else {
                msg.push(`Please contact emitter author to report this issue.`);
            }
            msg.push("");
            if (typeof error === "object" &&
                error !== null &&
                "stack" in error &&
                typeof error.stack === "string") {
                msg.push(error.stack);
            }
            else {
                msg.push(String(error));
            }
            throw new ExternalError(msg.join("\n"));
        }
    }
    /**
     * resolves a module specifier like "myLib" to an absolute path where we can find the main of
     * that module, e.g. "/typespec/node_modules/myLib/main.tsp".
     */
    async function resolveTypeSpecLibrary(specifier, baseDir, target) {
        try {
            return await resolveModule(getResolveModuleHost(), specifier, {
                baseDir,
                directoryIndexFiles: ["main.tsp", "index.mjs", "index.js"],
                resolveMain(pkg) {
                    var _c;
                    // this lets us follow node resolve semantics more-or-less exactly
                    // but using tspMain instead of main.
                    return (_c = resolveTspMain(pkg)) !== null && _c !== void 0 ? _c : pkg.main;
                },
            });
        }
        catch (e) {
            if (e.code === "MODULE_NOT_FOUND") {
                program.reportDiagnostic(createDiagnostic({ code: "import-not-found", format: { path: specifier }, target }));
                return undefined;
            }
            else if (e.code === "INVALID_MAIN") {
                program.reportDiagnostic(createDiagnostic({
                    code: "library-invalid",
                    format: { path: specifier },
                    messageId: "tspMain",
                    target,
                }));
                return undefined;
            }
            else {
                throw e;
            }
        }
    }
    /**
     * resolves a module specifier like "myLib" to an absolute path where we can find the main of
     * that module, e.g. "/typespec/node_modules/myLib/dist/lib.js".
     */
    async function resolveJSLibrary(specifier, baseDir) {
        try {
            return [await resolveModule(getResolveModuleHost(), specifier, { baseDir }), []];
        }
        catch (e) {
            if (e.code === "MODULE_NOT_FOUND") {
                return [
                    undefined,
                    [
                        createDiagnostic({
                            code: "import-not-found",
                            format: { path: specifier },
                            target: NoTarget,
                        }),
                    ],
                ];
            }
            else if (e.code === "INVALID_MAIN") {
                return [
                    undefined,
                    [
                        createDiagnostic({
                            code: "library-invalid",
                            format: { path: specifier },
                            target: NoTarget,
                        }),
                    ],
                ];
            }
            else {
                throw e;
            }
        }
    }
    function getResolveModuleHost() {
        return {
            realpath: host.realpath,
            stat: host.stat,
            readFile: async (path) => {
                const file = await host.readFile(path);
                return file.text;
            },
        };
    }
    /**
     * Resolve the path to the main file
     * @param path path to the entrypoint of the program. Can be the main.tsp, folder containing main.tsp or a project/library root.
     * @returns Absolute path to the entrypoint.
     */
    async function resolveTypeSpecEntrypoint(path) {
        const resolvedPath = resolvePath(path);
        const mainStat = await doIO(host.stat, resolvedPath, reportDiagnostic);
        if (!mainStat) {
            return undefined;
        }
        if (mainStat.isDirectory()) {
            return resolveTypeSpecEntrypointForDir(resolvedPath);
        }
        else {
            return resolvedPath;
        }
    }
    async function resolveTypeSpecEntrypointForDir(dir) {
        const pkgJsonPath = resolvePath(dir, "package.json");
        const [pkg] = await loadFile(host, pkgJsonPath, JSON.parse, reportDiagnostic, {
            allowFileNotFound: true,
        });
        const tspMain = resolveTspMain(pkg);
        if (tspMain !== undefined) {
            return resolvePath(dir, tspMain);
        }
        // Back Compat: if main.cadl exist, return main.cadl
        let mainFile = resolvePath(dir, "main.cadl");
        const stat = await doIO(() => host.stat(mainFile), mainFile, () => { });
        // if not found, use the normal resolution.
        if ((stat === null || stat === void 0 ? void 0 : stat.isFile()) !== true) {
            mainFile = resolvePath(dir, "main.tsp");
        }
        return mainFile;
    }
    /**
     * Load the main file from the given path
     * @param mainPath Absolute path to the main file.
     * @param options Compiler options.
     * @returns
     */
    async function loadMain(mainPath, options) {
        await checkForCompilerVersionMismatch(mainPath);
        const sourceFileKind = host.getSourceFileKind(mainPath);
        switch (sourceFileKind) {
            case "js":
                return await importJsFile(mainPath, NoTarget);
            case "typespec":
                return await loadTypeSpecFile(mainPath, NoTarget);
            default:
                program.reportDiagnostic(createDiagnostic({ code: "invalid-main", target: NoTarget }));
        }
    }
    // It's important that we use the compiler version that resolves locally
    // from the input TypeSpec source location. Otherwise, there will be undefined
    // runtime behavior when decorators and handlers expect a
    // different version of typespec than the current one. Abort the compilation
    // with an error if the TypeSpec entry point resolves to a different local
    // compiler.
    async function checkForCompilerVersionMismatch(mainPath) {
        const baseDir = getDirectoryPath(mainPath);
        let actual;
        try {
            const resolved = await resolveModule({
                realpath: host.realpath,
                stat: host.stat,
                readFile: async (path) => {
                    const file = await host.readFile(path);
                    return file.text;
                },
            }, "@typespec/compiler", { baseDir });
            compilerAssert(resolved.type === "module", `Expected to have resolved "@typespec/compiler" to a node module.`);
            actual = resolved;
        }
        catch (err) {
            if (err.code === "MODULE_NOT_FOUND" || err.code === "INVALID_MAIN") {
                return true; // no local typespec, ok to use any compiler
            }
            throw err;
        }
        const expected = resolvePath(await host.realpath(host.fileURLToPath(import.meta.url)), "../index.js");
        if (actual.mainFile !== expected && MANIFEST.version !== actual.manifest.version) {
            const betterTypeSpecServerPath = actual.path;
            program.reportDiagnostic(createDiagnostic({
                code: "compiler-version-mismatch",
                format: { basedir: baseDir, betterTypeSpecServerPath, actual: actual.mainFile, expected },
                target: NoTarget,
            }));
            return false;
        }
        return true;
    }
    function getOption(key) {
        return (options.miscOptions || {})[key];
    }
    function reportDiagnostic(diagnostic) {
        if (shouldSuppress(diagnostic)) {
            return;
        }
        if (options.warningAsError && diagnostic.severity === "warning") {
            diagnostic = { ...diagnostic, severity: "error" };
        }
        if (diagnostic.severity === "error") {
            error = true;
        }
        diagnostics.push(diagnostic);
    }
    function reportDiagnostics(newDiagnostics) {
        for (const diagnostic of newDiagnostics) {
            reportDiagnostic(diagnostic);
        }
    }
    function shouldSuppress(diagnostic) {
        const { target } = diagnostic;
        if (diagnostic.code === "error") {
            diagnostics.push(diagnostic);
            return false;
        }
        if (target === NoTarget || target === undefined) {
            return false;
        }
        if ("file" in target) {
            return false; // No global file suppress yet.
        }
        const node = getNode(target);
        if (node === undefined) {
            return false; // Can't find target cannot be suppressed.
        }
        const suppressing = findDirectiveSuppressingOnNode(diagnostic.code, node);
        if (suppressing) {
            if (diagnostic.severity === "error") {
                // Cannot suppress errors.
                diagnostics.push({
                    severity: "error",
                    code: "suppress-error",
                    message: "Errors cannot be suppressed.",
                    target: suppressing.node,
                });
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    }
    function findDirectiveSuppressingOnNode(code, node) {
        let current = node;
        do {
            if (current.directives) {
                const directive = findDirectiveSuppressingCode(code, current.directives);
                if (directive) {
                    return directive;
                }
            }
        } while ((current = current.parent));
        return undefined;
    }
    /**
     * Returns the directive node that is suppressing this code.
     * @param code Code to check for suppression.
     * @param directives List of directives.
     * @returns Directive suppressing this code if found, `undefined` otherwise
     */
    function findDirectiveSuppressingCode(code, directives) {
        for (const directive of directives.map((x) => parseDirective(x))) {
            if (directive.name === "suppress") {
                if (directive.code === code) {
                    return directive;
                }
            }
        }
        return undefined;
    }
    function parseDirective(node) {
        const args = node.arguments.map((x) => {
            return x.kind === SyntaxKind.Identifier ? x.sv : x.value;
        });
        switch (node.target.sv) {
            case "suppress":
                return { name: "suppress", code: args[0], message: args[1], node };
            default:
                throw new Error("Unexpected directive name.");
        }
    }
    function getNode(target) {
        if (!("kind" in target)) {
            // symbol
            if (target.flags & 524288 /* SymbolFlags.Using */) {
                return target.symbolSource.declarations[0];
            }
            return target.declarations[0]; // handle multiple decls
        }
        else if (typeof target.kind === "number") {
            // node
            return target;
        }
        else {
            // type
            return target.node;
        }
    }
    function reportDuplicateSymbols(symbols) {
        if (!symbols) {
            return;
        }
        for (const set of symbols.duplicates.values()) {
            for (const symbol of set) {
                if (!duplicateSymbols.has(symbol)) {
                    duplicateSymbols.add(symbol);
                    const name = symbol.flags & 524288 /* SymbolFlags.Using */ ? symbol.symbolSource.name : symbol.name;
                    reportDiagnostic(createDiagnostic({
                        code: "duplicate-symbol",
                        format: { name },
                        target: symbol,
                    }));
                }
            }
        }
    }
    function getGlobalNamespaceType() {
        return program.checker.getGlobalNamespaceType();
    }
    function resolveTypeReference(reference) {
        const [node, parseDiagnostics] = parseStandaloneTypeReference(reference);
        if (parseDiagnostics.length > 0) {
            return [undefined, parseDiagnostics];
        }
        const binder = createBinder(program);
        binder.bindNode(node);
        mutate(node).parent = program.checker.getGlobalNamespaceNode();
        return program.checker.resolveTypeReference(node);
    }
}
export function createStateAccessors(stateMaps, stateSets, projector) {
    function stateMap(key) {
        let m = stateMaps.get(key);
        if (!m) {
            m = new StateMap();
            stateMaps.set(key, m);
        }
        return new StateMapView(m, projector);
    }
    function stateSet(key) {
        let s = stateSets.get(key);
        if (!s) {
            s = new StateSet();
            stateSets.set(key, s);
        }
        return new StateSetView(s, projector);
    }
    return { stateMap, stateSet };
}
/**
 * Resolve compiler options from input options.
 */
function resolveOptions(options) {
    var _c;
    // eslint-disable-next-line deprecation/deprecation
    const outputDir = (_c = options.outputDir) !== null && _c !== void 0 ? _c : options.outputPath;
    return {
        ...options,
        outputDir,
        outputPath: outputDir,
    };
}
//# sourceMappingURL=program.js.map