var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _MultiKeyMap_currentId, _MultiKeyMap_idMap, _MultiKeyMap_items, _Queue_elements, _Queue_headIndex, _DuplicateTracker_entries, _RekeyableMapImpl_keys, _RekeyableMapImpl_values, _a;
import { createSourceFile } from "./diagnostics.js";
import { createDiagnostic } from "./messages.js";
import { getAnyExtensionFromPath, getDirectoryPath, isPathAbsolute, isUrl, joinPaths, normalizePath, resolvePath, } from "./path-utils.js";
import { NoTarget, } from "./types.js";
export { typespecVersion } from "./manifest.js";
export { NodeHost } from "./node-host.js";
export class ExternalError extends Error {
}
/**
 * Recursively calls Object.freeze such that all objects and arrays
 * referenced are frozen.
 *
 * Does not support cycles. Intended to be used only on plain data that can
 * be directly represented in JSON.
 */
export function deepFreeze(value) {
    if (Array.isArray(value)) {
        value.forEach(deepFreeze);
    }
    else if (typeof value === "object") {
        for (const prop in value) {
            deepFreeze(value[prop]);
        }
    }
    return Object.freeze(value);
}
/**
 * Deeply clones an object.
 *
 * Does not support cycles. Intended to be used only on plain data that can
 * be directly represented in JSON.
 */
export function deepClone(value) {
    if (Array.isArray(value)) {
        return value.map(deepClone);
    }
    if (typeof value === "object") {
        const obj = {};
        for (const prop in value) {
            obj[prop] = deepClone(value[prop]);
        }
        return obj;
    }
    return value;
}
/**
 * Checks if two objects are deeply equal.
 *
 * Does not support cycles. Intended to be used only on plain data that can
 * be directly represented in JSON.
 */
export function deepEquals(left, right) {
    if (left === right) {
        return true;
    }
    if (left === null || right === null || typeof left !== "object" || typeof right !== "object") {
        return false;
    }
    if (Array.isArray(left)) {
        return Array.isArray(right) ? arrayEquals(left, right, deepEquals) : false;
    }
    return mapEquals(new Map(Object.entries(left)), new Map(Object.entries(right)), deepEquals);
}
/**
 * Check if two arrays have the same elements.
 *
 * @param equals Optional callback for element equality comparison.
 *               Default is to compare by identity using `===`.
 */
export function arrayEquals(left, right, equals = (x, y) => x === y) {
    if (left === right) {
        return true;
    }
    if (left.length !== right.length) {
        return false;
    }
    for (let i = 0; i < left.length; i++) {
        if (!equals(left[i], right[i])) {
            return false;
        }
    }
    return true;
}
/**
 * Check if two maps have the same entries.
 *
 * @param equals Optional callback for value equality comparison.
 *               Default is to compare by identity using `===`.
 */
export function mapEquals(left, right, equals = (x, y) => x === y) {
    if (left === right) {
        return true;
    }
    if (left.size !== right.size) {
        return false;
    }
    for (const [key, value] of left) {
        if (!right.has(key) || !equals(value, right.get(key))) {
            return false;
        }
    }
    return true;
}
export async function getNormalizedRealPath(host, path) {
    return normalizePath(await host.realpath(path));
}
export async function doIO(action, path, reportDiagnostic, options) {
    var _b;
    let result;
    try {
        result = await action(path);
    }
    catch (e) {
        let diagnostic;
        let target = (_b = options === null || options === void 0 ? void 0 : options.diagnosticTarget) !== null && _b !== void 0 ? _b : NoTarget;
        // blame the JS file, not the TypeSpec import statement for JS syntax errors.
        if (e instanceof SyntaxError && (options === null || options === void 0 ? void 0 : options.jsDiagnosticTarget)) {
            target = options.jsDiagnosticTarget;
        }
        switch (e.code) {
            case "ENOENT":
                if (options === null || options === void 0 ? void 0 : options.allowFileNotFound) {
                    return undefined;
                }
                diagnostic = createDiagnostic({ code: "file-not-found", target, format: { path } });
                break;
            default:
                diagnostic = createDiagnostic({
                    code: "file-load",
                    target,
                    format: { message: e.message },
                });
                break;
        }
        reportDiagnostic(diagnostic);
        return undefined;
    }
    return result;
}
export async function loadFile(host, path, load, reportDiagnostic, options) {
    const file = await doIO(host.readFile, path, reportDiagnostic, options);
    if (!file) {
        return [undefined, createSourceFile("", path)];
    }
    let data;
    try {
        data = load(file.text);
    }
    catch (e) {
        reportDiagnostic({
            code: "file-load",
            message: e.message,
            severity: "error",
            target: { file, pos: 1, end: 1 },
        });
        return [undefined, file];
    }
    return [data, file];
}
export async function readUrlOrPath(host, pathOrUrl) {
    if (isUrl(pathOrUrl)) {
        return host.readUrl(pathOrUrl);
    }
    return host.readFile(pathOrUrl);
}
export function resolveRelativeUrlOrPath(base, relativeOrAbsolute) {
    if (isUrl(relativeOrAbsolute)) {
        return relativeOrAbsolute;
    }
    else if (isPathAbsolute(relativeOrAbsolute)) {
        return relativeOrAbsolute;
    }
    else if (isUrl(base)) {
        return new URL(relativeOrAbsolute, base).href;
    }
    else {
        return resolvePath(base, relativeOrAbsolute);
    }
}
/**
 * A specially typed version of `Array.isArray` to work around [this issue](https://github.com/microsoft/TypeScript/issues/17002).
 */
export function isArray(
// eslint-disable-next-line @typescript-eslint/ban-types
arg) {
    return Array.isArray(arg);
}
/**
 * Check if argument is not undefined.
 */
export function isDefined(arg) {
    return arg !== undefined;
}
/**
 * Remove undefined properties from object.
 */
export function omitUndefined(data) {
    return Object.fromEntries(Object.entries(data).filter(([k, v]) => v !== undefined));
}
/**
 * Look for the project root by looking up until a `package.json` is found.
 * @param path Path to start looking
 * @param lookIn
 */
export async function findProjectRoot(host, path) {
    let current = path;
    while (true) {
        const pkgPath = joinPaths(current, "package.json");
        const stat = await doIO(() => host.stat(pkgPath), pkgPath, () => { });
        if (stat === null || stat === void 0 ? void 0 : stat.isFile()) {
            return current;
        }
        const parent = getDirectoryPath(current);
        if (parent === current) {
            return undefined;
        }
        current = parent;
    }
}
/**
 * Extract package.json's tspMain entry point in a given path. Note, it takes into
 * back compat for deprecated cadlMain
 * @param path Path that contains package.json
 * @param reportDiagnostic optional diagnostic handler.
 */
export function resolveTspMain(packageJson) {
    if ((packageJson === null || packageJson === void 0 ? void 0 : packageJson.tspMain) !== undefined) {
        return packageJson.tspMain;
    }
    if ((packageJson === null || packageJson === void 0 ? void 0 : packageJson.cadlMain) !== undefined) {
        return packageJson.cadlMain;
    }
    return undefined;
}
/**
 * A map keyed by a set of objects.
 *
 * This is likely non-optimal.
 */
export class MultiKeyMap {
    constructor() {
        _MultiKeyMap_currentId.set(this, 0);
        _MultiKeyMap_idMap.set(this, new WeakMap());
        _MultiKeyMap_items.set(this, new Map());
    }
    get(items) {
        return __classPrivateFieldGet(this, _MultiKeyMap_items, "f").get(this.compositeKeyFor(items));
    }
    set(items, value) {
        const key = this.compositeKeyFor(items);
        __classPrivateFieldGet(this, _MultiKeyMap_items, "f").set(key, value);
    }
    compositeKeyFor(items) {
        return items.map((i) => this.keyFor(i)).join(",");
    }
    keyFor(item) {
        var _b, _c;
        if (__classPrivateFieldGet(this, _MultiKeyMap_idMap, "f").has(item)) {
            return __classPrivateFieldGet(this, _MultiKeyMap_idMap, "f").get(item);
        }
        const id = (__classPrivateFieldSet(this, _MultiKeyMap_currentId, (_c = __classPrivateFieldGet(this, _MultiKeyMap_currentId, "f"), _b = _c++, _c), "f"), _b);
        __classPrivateFieldGet(this, _MultiKeyMap_idMap, "f").set(item, id);
        return id;
    }
}
_MultiKeyMap_currentId = new WeakMap(), _MultiKeyMap_idMap = new WeakMap(), _MultiKeyMap_items = new WeakMap();
/**
 * A map with exactly two keys per value.
 *
 * Functionally the same as `MultiKeyMap<[K1, K2], V>`, but more efficient.
 */
export class TwoLevelMap extends Map {
    /**
     * Get an existing entry in the map or add a new one if not found.
     *
     * @param key1 The first key
     * @param key2 The second key
     * @param create A callback to create the new entry when not found.
     * @param sentinel An optional sentinel value to use to indicate that the
     *                 entry is being created.
     */
    getOrAdd(key1, key2, create, sentinel) {
        let map = this.get(key1);
        if (map === undefined) {
            map = new Map();
            this.set(key1, map);
        }
        let entry = map.get(key2);
        if (entry === undefined) {
            if (sentinel !== undefined) {
                map.set(key2, sentinel);
            }
            entry = create();
            map.set(key2, entry);
        }
        return entry;
    }
}
// Adapted from https://github.com/microsoft/TypeScript/blob/bc52ff6f4be9347981de415a35da90497eae84ac/src/compiler/core.ts#L1507
export class Queue {
    constructor(elements) {
        var _b;
        _Queue_elements.set(this, void 0);
        _Queue_headIndex.set(this, 0);
        __classPrivateFieldSet(this, _Queue_elements, (_b = elements === null || elements === void 0 ? void 0 : elements.slice()) !== null && _b !== void 0 ? _b : [], "f");
    }
    isEmpty() {
        return __classPrivateFieldGet(this, _Queue_headIndex, "f") === __classPrivateFieldGet(this, _Queue_elements, "f").length;
    }
    enqueue(...items) {
        __classPrivateFieldGet(this, _Queue_elements, "f").push(...items);
    }
    dequeue() {
        var _b;
        if (this.isEmpty()) {
            throw new Error("Queue is empty.");
        }
        const result = __classPrivateFieldGet(this, _Queue_elements, "f")[__classPrivateFieldGet(this, _Queue_headIndex, "f")];
        __classPrivateFieldGet(this, _Queue_elements, "f")[__classPrivateFieldGet(this, _Queue_headIndex, "f")] = undefined; // Don't keep referencing dequeued item
        __classPrivateFieldSet(this, _Queue_headIndex, // Don't keep referencing dequeued item
        (_b = __classPrivateFieldGet(this, _Queue_headIndex, "f"), _b++, _b), "f");
        // If more than half of the queue is empty, copy the remaining elements to the
        // front and shrink the array (unless we'd be saving fewer than 100 slots)
        if (__classPrivateFieldGet(this, _Queue_headIndex, "f") > 100 && __classPrivateFieldGet(this, _Queue_headIndex, "f") > __classPrivateFieldGet(this, _Queue_elements, "f").length >> 1) {
            const newLength = __classPrivateFieldGet(this, _Queue_elements, "f").length - __classPrivateFieldGet(this, _Queue_headIndex, "f");
            __classPrivateFieldGet(this, _Queue_elements, "f").copyWithin(0, __classPrivateFieldGet(this, _Queue_headIndex, "f"));
            __classPrivateFieldGet(this, _Queue_elements, "f").length = newLength;
            __classPrivateFieldSet(this, _Queue_headIndex, 0, "f");
        }
        return result;
    }
}
_Queue_elements = new WeakMap(), _Queue_headIndex = new WeakMap();
/**
 * Casts away readonly typing.
 *
 * Use it like this when it is safe to override readonly typing:
 *   mutate(item).prop = value;
 */
export function mutate(value) {
    return value;
}
export function getSourceFileKindFromExt(path) {
    const ext = getAnyExtensionFromPath(path);
    if (ext === ".js" || ext === ".mjs") {
        return "js";
    }
    else if (ext === ".tsp" || ext === ".cadl") {
        return "typespec";
    }
    else {
        return undefined;
    }
}
export function createStringMap(caseInsensitive) {
    return caseInsensitive ? new CaseInsensitiveMap() : new Map();
}
class CaseInsensitiveMap extends Map {
    get(key) {
        return super.get(key.toUpperCase());
    }
    set(key, value) {
        return super.set(key.toUpperCase(), value);
    }
    has(key) {
        return super.has(key.toUpperCase());
    }
    delete(key) {
        return super.delete(key.toUpperCase());
    }
}
/**
 * Helper class to track duplicate instance
 */
export class DuplicateTracker {
    constructor() {
        _DuplicateTracker_entries.set(this, new Map());
    }
    /**
     * Track usage of K.
     * @param k key that is being checked for duplicate.
     * @param v value that map to the key
     */
    track(k, v) {
        const existing = __classPrivateFieldGet(this, _DuplicateTracker_entries, "f").get(k);
        if (existing === undefined) {
            __classPrivateFieldGet(this, _DuplicateTracker_entries, "f").set(k, [v]);
        }
        else {
            existing.push(v);
        }
    }
    /**
     * Return iterator of all the duplicate entries.
     */
    *entries() {
        for (const [k, v] of __classPrivateFieldGet(this, _DuplicateTracker_entries, "f").entries()) {
            if (v.length > 1) {
                yield [k, v];
            }
        }
    }
}
_DuplicateTracker_entries = new WeakMap();
export function createRekeyableMap(entries) {
    return new RekeyableMapImpl(entries);
}
class RekeyableMapImpl {
    constructor(entries) {
        _RekeyableMapImpl_keys.set(this, new Map());
        _RekeyableMapImpl_values.set(this, new Map());
        this[_a] = "RekeyableMap";
        if (entries) {
            for (const [key, value] of entries) {
                this.set(key, value);
            }
        }
    }
    clear() {
        __classPrivateFieldGet(this, _RekeyableMapImpl_keys, "f").clear();
        __classPrivateFieldGet(this, _RekeyableMapImpl_values, "f").clear();
    }
    delete(key) {
        const keyItem = __classPrivateFieldGet(this, _RekeyableMapImpl_keys, "f").get(key);
        if (keyItem) {
            __classPrivateFieldGet(this, _RekeyableMapImpl_keys, "f").delete(key);
            return __classPrivateFieldGet(this, _RekeyableMapImpl_values, "f").delete(keyItem);
        }
        return false;
    }
    forEach(callbackfn, thisArg) {
        __classPrivateFieldGet(this, _RekeyableMapImpl_values, "f").forEach((value, keyItem) => {
            callbackfn(value, keyItem.key, this);
        }, thisArg);
    }
    get(key) {
        const keyItem = __classPrivateFieldGet(this, _RekeyableMapImpl_keys, "f").get(key);
        return keyItem ? __classPrivateFieldGet(this, _RekeyableMapImpl_values, "f").get(keyItem) : undefined;
    }
    has(key) {
        return __classPrivateFieldGet(this, _RekeyableMapImpl_keys, "f").has(key);
    }
    set(key, value) {
        let keyItem = __classPrivateFieldGet(this, _RekeyableMapImpl_keys, "f").get(key);
        if (!keyItem) {
            keyItem = { key };
            __classPrivateFieldGet(this, _RekeyableMapImpl_keys, "f").set(key, keyItem);
        }
        __classPrivateFieldGet(this, _RekeyableMapImpl_values, "f").set(keyItem, value);
        return this;
    }
    get size() {
        return __classPrivateFieldGet(this, _RekeyableMapImpl_values, "f").size;
    }
    *entries() {
        for (const [k, v] of __classPrivateFieldGet(this, _RekeyableMapImpl_values, "f")) {
            yield [k.key, v];
        }
    }
    *keys() {
        for (const k of __classPrivateFieldGet(this, _RekeyableMapImpl_values, "f").keys()) {
            yield k.key;
        }
    }
    values() {
        return __classPrivateFieldGet(this, _RekeyableMapImpl_values, "f").values();
    }
    [(_RekeyableMapImpl_keys = new WeakMap(), _RekeyableMapImpl_values = new WeakMap(), Symbol.iterator)]() {
        return this.entries();
    }
    rekey(existingKey, newKey) {
        const keyItem = __classPrivateFieldGet(this, _RekeyableMapImpl_keys, "f").get(existingKey);
        if (!keyItem) {
            return false;
        }
        __classPrivateFieldGet(this, _RekeyableMapImpl_keys, "f").delete(existingKey);
        keyItem.key = newKey;
        __classPrivateFieldGet(this, _RekeyableMapImpl_keys, "f").set(newKey, keyItem);
        return true;
    }
}
_a = Symbol.toStringTag;
//# sourceMappingURL=util.js.map