import { Program, ProjectedProgram } from "../core/program.js";
import { ArrayModelType, DecoratorContext, Enum, EnumMember, Interface, Model, ModelIndexer, ModelProperty, Namespace, Operation, Scalar, Type, Union } from "../core/types.js";
export * from "./service.js";
export declare const namespace = "TypeSpec";
/**
 * @summary attaches a documentation string. It is typically used to give a short, single-line
 * description, and can be used in combination with or instead of @doc.
 *
 * The first argument to @summary is a string, which may contain template parameters, enclosed in braces,
 * which are replaced with an attribute for the type (commonly "name") passed as the second (optional) argument.
 *
 * @summary can be specified on any language element -- a model, an operation, a namespace, etc.
 */
export declare function $summary(context: DecoratorContext, target: Type, text: string, sourceObject: Type): void;
export declare function getSummary(program: Program, type: Type): string | undefined;
/**
 * @doc attaches a documentation string. Works great with multi-line string literals.
 *
 * The first argument to @doc is a string, which may contain template parameters, enclosed in braces,
 * which are replaced with an attribute for the type (commonly "name") passed as the second (optional) argument.
 *
 * @doc can be specified on any language element -- a model, an operation, a namespace, etc.
 */
export declare function $doc(context: DecoratorContext, target: Type, text: string, sourceObject?: Type): void;
export declare function getDoc(program: Program, target: Type): string | undefined;
export declare function $inspectType(program: Program, target: Type, text: string): void;
export declare function $inspectTypeName(program: Program, target: Type, text: string): void;
export declare function $indexer(context: DecoratorContext, target: Type, key: Scalar, value: Type): void;
export declare function getIndexer(program: Program, target: Type): ModelIndexer | undefined;
export declare function isStringType(program: Program | ProjectedProgram, target: Type): target is Scalar;
export declare function isNumericType(program: Program | ProjectedProgram, target: Type): target is Scalar;
/**
 * Check if a model is an array type.
 * @param type Model type
 */
export declare function isArrayModelType(program: Program, type: Model): type is ArrayModelType;
/**
 * Check if a model is an array type.
 * @param type Model type
 */
export declare function isRecordModelType(program: Program, type: Model): type is ArrayModelType;
/**
 * Return the type of the property or the model itself.
 */
export declare function getPropertyType(target: Scalar | ModelProperty): Type;
/**
 * `@error` decorator marks a model as an error type.
 *
 * `@error` can only be specified on a model.
 */
export declare function $error(context: DecoratorContext, entity: Model): void;
export declare function isErrorModel(program: Program, target: Type): boolean;
/**
 * `@format` - specify the data format hint for a string type
 *
 * The first argument is a string that identifies the format that the string type expects.  Any string
 * can be entered here, but a TypeSpec emitter must know how to interpret
 *
 * For TypeSpec specs that will be used with an OpenAPI emitter, the OpenAPI specification describes possible
 * valid values for a string type's format:
 *
 * https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#dataTypes
 *
 * `@format` can be specified on a type that extends from `string` or a `string`-typed model property.
 */
export declare function $format(context: DecoratorContext, target: Scalar | ModelProperty, format: string): void;
export declare function getFormat(program: Program, target: Type): string | undefined;
export declare function $pattern(context: DecoratorContext, target: Scalar | ModelProperty, pattern: string): void;
export declare function getPattern(program: Program, target: Type): string | undefined;
export declare function $minLength(context: DecoratorContext, target: Scalar | ModelProperty, minLength: number): void;
export declare function getMinLength(program: Program, target: Type): number | undefined;
export declare function $maxLength(context: DecoratorContext, target: Scalar | ModelProperty, maxLength: number): void;
export declare function getMaxLength(program: Program, target: Type): number | undefined;
export declare function $minItems(context: DecoratorContext, target: Model | ModelProperty, minItems: number): void;
export declare function getMinItems(program: Program, target: Type): number | undefined;
export declare function $maxItems(context: DecoratorContext, target: Model | ModelProperty, maxItems: number): void;
export declare function getMaxItems(program: Program, target: Type): number | undefined;
export declare function $minValue(context: DecoratorContext, target: Scalar | ModelProperty, minValue: number): void;
export declare function getMinValue(program: Program, target: Type): number | undefined;
export declare function $maxValue(context: DecoratorContext, target: Scalar | ModelProperty, maxValue: number): void;
export declare function getMaxValue(program: Program, target: Type): number | undefined;
export declare function $minValueExclusive(context: DecoratorContext, target: Scalar | ModelProperty, minValueExclusive: number): void;
export declare function getMinValueExclusive(program: Program, target: Type): number | undefined;
export declare function $maxValueExclusive(context: DecoratorContext, target: Scalar | ModelProperty, maxValueExclusive: number): void;
export declare function getMaxValueExclusive(program: Program, target: Type): number | undefined;
/**
 * Mark a string as a secret value that should be treated carefully to avoid exposure
 * @param context Decorator context
 * @param target Decorator target, either a string model or a property with type string.
 */
export declare function $secret(context: DecoratorContext, target: Scalar | ModelProperty): void;
export declare function isSecret(program: Program, target: Type): boolean | undefined;
export type DateTimeKnownEncoding = "rfc3339" | "rfc7231" | "unixTimeStamp";
export type DurationKnownEncoding = "ISO8601" | "seconds";
export type BytesKnownEncoding = "base64" | "base64url";
export interface EncodeData {
    encoding: DateTimeKnownEncoding | DurationKnownEncoding | string;
    type: Scalar;
}
export declare function $encode(context: DecoratorContext, target: Scalar | ModelProperty, encoding: string | EnumMember, encodeAs?: Scalar): void;
export declare function getEncode(program: Program, target: Scalar | ModelProperty): EncodeData | undefined;
export declare function $visibility(context: DecoratorContext, target: ModelProperty, ...visibilities: string[]): void;
export declare function getVisibility(program: Program, target: Type): string[] | undefined;
export declare function $withVisibility(context: DecoratorContext, target: Model, ...visibilities: string[]): void;
export declare function isVisible(program: Program, property: ModelProperty, visibilities: readonly string[]): boolean;
export declare function $withOptionalProperties(context: DecoratorContext, target: Model): void;
export declare function $withUpdateableProperties(context: DecoratorContext, target: Type): void;
export declare function $withoutOmittedProperties(context: DecoratorContext, target: Model, omitProperties: string | Union): void;
export declare function $withoutDefaultValues(context: DecoratorContext, target: Model): void;
export declare function $list(context: DecoratorContext, target: Operation, listedType?: Type): void;
export declare function getListOperationType(program: Program, target: Type): Model | undefined;
export declare function isListOperation(program: Program, target: Operation): boolean;
export declare function $tag(context: DecoratorContext, target: Operation | Namespace | Interface, tag: string): void;
export declare function getTags(program: Program, target: Type): string[];
export declare function getAllTags(program: Program, target: Namespace | Interface | Operation): string[] | undefined;
export declare function $friendlyName(context: DecoratorContext, target: Type, friendlyName: string, sourceObject: Type | undefined): void;
export declare function getFriendlyName(program: Program, target: Type): string;
/**
 * `@knownValues` marks a string type with an enum that contains all known values
 *
 * The first parameter is a reference to an enum type that describes all possible values that the
 * type accepts.
 *
 * `@knownValues` can only be applied to model types that extend `string`.
 *
 * @param target Decorator target. Must be a string. (model Foo extends string)
 * @param knownValues Must be an enum.
 */
export declare function $knownValues(context: DecoratorContext, target: Scalar | ModelProperty, knownValues: Enum): void;
export declare function getKnownValues(program: Program, target: Scalar | ModelProperty): Enum | undefined;
/**
 * `@key` - mark a model property as the key to identify instances of that type
 *
 * The optional first argument accepts an alternate key name which may be used by emitters.
 * Otherwise, the name of the target property will be used.
 *
 * `@key` can only be applied to model properties.
 */
export declare function $key(context: DecoratorContext, entity: ModelProperty, altName?: string): void;
export declare function isKey(program: Program, property: ModelProperty): boolean;
export declare function getKeyName(program: Program, property: ModelProperty): string;
export declare function $withDefaultKeyVisibility(context: DecoratorContext, entity: Model, visibility: string): void;
/**
 * Mark a type as deprecated
 * @param context DecoratorContext
 * @param target Decorator target
 * @param message Deprecation target.
 *
 * @example
 * ``` @deprecated("Foo is deprecated, use Bar instead.")
 *     model Foo {}
 * ```
 */
export declare function $deprecated(context: DecoratorContext, target: Type, message: string): Map<Type, any>;
/**
 * Check if the given type is deprecated
 * @param program Program
 * @param type Type
 */
export declare function isDeprecated(program: Program, type: Type): boolean;
/**
 * Return the deprecated message or undefined if not deprecated
 * @param program Program
 * @param type Type
 */
export declare function getDeprecated(program: Program, type: Type): string | undefined;
/**
 * `@overload` - Indicate that the target overloads (specializes) the overloads type.
 * @param context DecoratorContext
 * @param target The specializing operation declaration
 * @param overloadBase The operation to be overloaded.
 */
export declare function $overload(context: DecoratorContext, target: Operation, overloadBase: Operation): void;
/**
 * Get all operations that are marked as overloads of the given operation
 * @param program Program
 * @param operation Operation
 * @returns An array of operations that overload the given operation.
 */
export declare function getOverloads(program: Program, operation: Operation): Operation[] | undefined;
/**
 * If the given operation overloads another operation, return that operation.
 * @param program Program
 * @param operation The operation to check for an overload target.
 * @returns The operation this operation overloads, if any.
 */
export declare function getOverloadedOperation(program: Program, operation: Operation): Operation | undefined;
/**
 * `@projectedName` - Indicate that this entity should be renamed according to the given projection.
 * @param context DecoratorContext
 * @param target The that should have a different name.
 * @param projectionName Name of the projection (e.g. "toJson", "toCSharp")
 * @param projectedName Name of the type should have in the scope of the projection specified.
 */
export declare function $projectedName(context: DecoratorContext, target: Type, projectionName: string, projectedName: string): void;
/**
 * @param program Program
 * @param target Target
 * @returns Map of the projected names for the given entity.
 */
export declare function getProjectedNames(program: Program, target: Type): ReadonlyMap<string, string> | undefined;
/**
 * Get the projected name of the given entity for the given projection.
 * @param program Program
 * @param target Target
 * @returns Projected name for the given projection
 */
export declare function getProjectedName(program: Program, target: Type, projectionName: string): string | undefined;
/**
 * Get the projected name of the given entity for the given projection.
 * @param program Program
 * @param target Target
 * @returns Projected name for the given projection
 */
export declare function hasProjectedName(program: Program, target: Type, projectionName: string): boolean;
export interface Discriminator {
    propertyName: string;
}
export declare function $discriminator(context: DecoratorContext, entity: Model | Union, propertyName: string): void;
export declare function getDiscriminator(program: Program, entity: Type): Discriminator | undefined;
export declare function getDiscriminatedTypes(program: Program): [Model | Union, Discriminator][];
//# sourceMappingURL=decorators.d.ts.map