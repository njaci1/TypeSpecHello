import { JSONSchemaType } from "@typespec/compiler";
export type FileType = "yaml" | "json";
export interface OpenAPI3EmitterOptions {
    /**
     * If the content should be serialized as YAML or JSON.
     * @default yaml, it not specified infer from the `output-file` extension
     */
    "file-type"?: FileType;
    /**
     * Name of the output file.
     * Output file will interpolate the following values:
     *  - service-name: Name of the service if multiple
     *  - version: Version of the service if multiple
     *
     * @default `{service-name}.{version}.openapi.yaml` or `.json` if {@link OpenAPI3EmitterOptions["file-type"]} is `"json"`
     *
     * @example Single service no versioning
     *  - `openapi.yaml`
     *
     * @example Multiple services no versioning
     *  - `openapi.Org1.Service1.yaml`
     *  - `openapi.Org1.Service2.yaml`
     *
     * @example Single service with versioning
     *  - `openapi.v1.yaml`
     *  - `openapi.v2.yaml`
     *
     * @example Multiple service with versioning
     *  - `openapi.Org1.Service1.v1.yaml`
     *  - `openapi.Org1.Service1.v2.yaml`
     *  - `openapi.Org1.Service2.v1.0.yaml`
     *  - `openapi.Org1.Service2.v1.1.yaml`
     */
    "output-file"?: string;
    /**
     * Set the newline character for emitting files.
     * @default lf
     */
    "new-line"?: "crlf" | "lf";
    /**
     * Omit unreachable types.
     * By default all types declared under the service namespace will be included. With this flag on only types references in an operation will be emitted.
     */
    "omit-unreachable-types"?: boolean;
}
export declare const libDef: {
    readonly name: "@typespec/openapi3";
    readonly diagnostics: {
        readonly "invalid-server-variable": {
            readonly severity: "error";
            readonly messages: {
                readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
            };
        };
        readonly "resource-namespace": {
            readonly severity: "error";
            readonly messages: {
                readonly default: "Resource goes on namespace";
            };
        };
        readonly "path-query": {
            readonly severity: "error";
            readonly messages: {
                readonly default: "OpenAPI does not allow paths containing a query string.";
            };
        };
        readonly "duplicate-body": {
            readonly severity: "error";
            readonly messages: {
                readonly default: "Duplicate @body declarations on response type";
            };
        };
        readonly "duplicate-header": {
            readonly severity: "error";
            readonly messages: {
                readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
            };
        };
        readonly "status-code-in-default-response": {
            readonly severity: "error";
            readonly messages: {
                readonly default: "a default response should not have an explicit status code";
            };
        };
        readonly "invalid-schema": {
            readonly severity: "error";
            readonly messages: {
                readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
            };
        };
        readonly "union-null": {
            readonly severity: "error";
            readonly messages: {
                readonly default: "Cannot have a union containing only null types.";
            };
        };
        readonly "union-unsupported": {
            readonly severity: "error";
            readonly messages: {
                readonly default: "Unions are not supported unless all options are literals of the same type.";
                readonly type: import("@typespec/compiler").CallableMessage<["kind"]>;
                readonly empty: "Empty unions are not supported for OpenAPI v3 - enums must have at least one value.";
                readonly null: "Unions containing multiple model types cannot be emitted to OpenAPI v2 unless the union is between one model type and 'null'.";
            };
        };
        readonly "invalid-default": {
            readonly severity: "error";
            readonly messages: {
                readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
            };
        };
        readonly "inline-cycle": {
            readonly severity: "error";
            readonly messages: {
                readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
            };
        };
    };
    readonly emitter: {
        readonly options: JSONSchemaType<OpenAPI3EmitterOptions>;
    };
};
export declare const $lib: import("@typespec/compiler").TypeSpecLibrary<{
    "invalid-server-variable": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "resource-namespace": {
        readonly default: "Resource goes on namespace";
    };
    "path-query": {
        readonly default: "OpenAPI does not allow paths containing a query string.";
    };
    "duplicate-body": {
        readonly default: "Duplicate @body declarations on response type";
    };
    "duplicate-header": {
        readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
    };
    "status-code-in-default-response": {
        readonly default: "a default response should not have an explicit status code";
    };
    "invalid-schema": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-unsupported": {
        readonly default: "Unions are not supported unless all options are literals of the same type.";
        readonly type: import("@typespec/compiler").CallableMessage<["kind"]>;
        readonly empty: "Empty unions are not supported for OpenAPI v3 - enums must have at least one value.";
        readonly null: "Unions containing multiple model types cannot be emitted to OpenAPI v2 unless the union is between one model type and 'null'.";
    };
    "invalid-default": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "inline-cycle": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
}, OpenAPI3EmitterOptions>;
export declare const reportDiagnostic: <C extends "invalid-server-variable" | "resource-namespace" | "path-query" | "duplicate-body" | "duplicate-header" | "status-code-in-default-response" | "invalid-schema" | "union-null" | "union-unsupported" | "invalid-default" | "inline-cycle", M extends keyof {
    "invalid-server-variable": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "resource-namespace": {
        readonly default: "Resource goes on namespace";
    };
    "path-query": {
        readonly default: "OpenAPI does not allow paths containing a query string.";
    };
    "duplicate-body": {
        readonly default: "Duplicate @body declarations on response type";
    };
    "duplicate-header": {
        readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
    };
    "status-code-in-default-response": {
        readonly default: "a default response should not have an explicit status code";
    };
    "invalid-schema": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-unsupported": {
        readonly default: "Unions are not supported unless all options are literals of the same type.";
        readonly type: import("@typespec/compiler").CallableMessage<["kind"]>;
        readonly empty: "Empty unions are not supported for OpenAPI v3 - enums must have at least one value.";
        readonly null: "Unions containing multiple model types cannot be emitted to OpenAPI v2 unless the union is between one model type and 'null'.";
    };
    "invalid-default": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "inline-cycle": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
}[C]>(program: import("@typespec/compiler").Program, diag: import("@typespec/compiler").DiagnosticReport<{
    "invalid-server-variable": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "resource-namespace": {
        readonly default: "Resource goes on namespace";
    };
    "path-query": {
        readonly default: "OpenAPI does not allow paths containing a query string.";
    };
    "duplicate-body": {
        readonly default: "Duplicate @body declarations on response type";
    };
    "duplicate-header": {
        readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
    };
    "status-code-in-default-response": {
        readonly default: "a default response should not have an explicit status code";
    };
    "invalid-schema": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "union-unsupported": {
        readonly default: "Unions are not supported unless all options are literals of the same type.";
        readonly type: import("@typespec/compiler").CallableMessage<["kind"]>;
        readonly empty: "Empty unions are not supported for OpenAPI v3 - enums must have at least one value.";
        readonly null: "Unions containing multiple model types cannot be emitted to OpenAPI v2 unless the union is between one model type and 'null'.";
    };
    "invalid-default": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "inline-cycle": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
}, C, M>) => void, createStateSymbol: (name: string) => symbol;
export type OpenAPILibrary = typeof $lib;
//# sourceMappingURL=lib.d.ts.map